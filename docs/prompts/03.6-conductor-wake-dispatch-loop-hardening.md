# Prompt 03.6: Conductor Full Agentic Orchestration Cutover

You are working in `/Users/wiz/choiros-rs`.

## Narrative Summary (1-minute read)
Conductor is still executing deterministic workflows (`Terminal -> Researcher`) and treating worker outputs as mostly linear step results. That is incompatible with the target architecture. This prompt is an immediate cutover to fully agentic orchestration: Conductor must decide capabilities dynamically, delegate natural-language objectives to capability agents, react to typed runtime signals, and continuously replan until objective completion, failure, or block.

No fixed worker order is allowed as control authority.

## What Changed
- 03.5 introduced typed run structures, agenda/call/decision/artifact models, and wake/display lanes.
- Follow-up patches fixed telemetry, metadata parsing, and run/task identity.
- Core orchestration remains deterministic because:
  - legacy `ExecuteTask -> build_default_plan -> execute_worker_plan(for loop)` is still active,
  - `ProcessEvent` and `DispatchReady` are not full decision engines,
  - watcher alerts are not integrated into conductor decisions.

## What To Do Next
Replace deterministic orchestration with a typed, event-driven policy loop where Conductor:
- chooses next capabilities from runtime state,
- updates agenda dynamically,
- reprompts/retries/refines based on typed worker and watcher signals,
- never relies on preset worker sequences,
- uses dedicated BAML contracts for Conductor decisions and Watcher triage.
- keeps delegation payloads as natural-language objectives for Terminal/Researcher/etc.

## Mission
Cut over Conductor from deterministic plan-runner to fully agentic orchestrator.

Conductor must:
1. own a long-lived run state machine (`run/agenda/calls/decisions/artifacts`),
2. dispatch capabilities based on typed readiness + policy decisions,
3. consume typed worker outcomes (`complete/incomplete/blocked`, recommendations, artifacts),
4. consume watcher escalations as wake events,
5. replan continuously until terminal run status.

This cutover requires BAML contracts for both Conductor and Watcher policy surfaces.

## Architecture Requirements (Hard Rules)
1. Follow AGENTS.md `Model-Led Control Flow` hard rule.
2. No natural-language string matching for control transitions.
3. No deterministic default workflow authority (`Terminal -> Researcher` etc.).
4. Keep backward compatibility only at API surface; runtime control must be agentic.
5. Wake/display separation must remain enforced:
   - wake events can trigger policy/dispatch,
   - display-only events never control orchestration.
6. Preserve typed identity and scope:
   - `run_id`, `task_id`, `call_id` must remain distinct.
7. Natural-language objective delegation is required for capability calls; typed fields govern control authority.
8. Deterministic fallback paths are prohibited; policy/model failures must produce explicit typed failure/block transitions.

## Read First
- `/Users/wiz/choiros-rs/AGENTS.md`
- `/Users/wiz/choiros-rs/sandbox/src/actors/conductor/actor.rs`
- `/Users/wiz/choiros-rs/sandbox/src/actors/conductor/state.rs`
- `/Users/wiz/choiros-rs/sandbox/src/actors/conductor/protocol.rs`
- `/Users/wiz/choiros-rs/sandbox/src/actors/conductor/events.rs`
- `/Users/wiz/choiros-rs/sandbox/src/actors/researcher.rs`
- `/Users/wiz/choiros-rs/sandbox/src/actors/terminal.rs`
- `/Users/wiz/choiros-rs/sandbox/src/actors/watcher.rs`
- `/Users/wiz/choiros-rs/shared-types/src/lib.rs`

## Implement

### Phase 0: Add BAML Contracts (Mandatory)
Add dedicated BAML functions and types for orchestration policy.

Required scope:
- `baml_src`: add Conductor decision function(s) and Watcher triage function(s)
- regenerate BAML client outputs
- keep `sandbox/src/baml_client/baml_source_map.rs` synchronized

Minimum Conductor BAML outputs:
- decision type (`dispatch`, `retry`, `spawn_followup`, `continue`, `complete`, `block`)
- target agenda item ids
- optional spawned agenda items
- optional retry/backoff policy
- completion/block reason

Minimum Watcher BAML outputs:
- log-window assessment
- escalation action(s)
- urgency
- recommended capability/objective
- typed rationale

Constraint:
- Watcher must review EventStore windows via LLM-driven analysis and emit typed outputs.
- Watcher model policy must be lower-power than Conductor model policy.

### Phase A: Remove Deterministic Workflow Authority
Refactor Conductor so runtime control is not governed by static worker sequences.

Required changes:
- Remove `build_default_plan` as orchestration authority.
- Remove/retire `execute_worker_plan` deterministic for-loop as orchestration authority.
- Introduce policy-driven agenda mutation and dispatch decisions in actor message flow.

Allowed compatibility:
- Keep legacy request schema (`ConductorExecuteRequest`) and endpoint behavior.
- If `worker_plan` is supplied, treat it as initial agenda seed only, not immutable execution script.

### Phase B: Policy-Driven Decision Loop
Implement a typed decision loop in Conductor actor:
- Input signals:
  - agenda readiness,
  - active call outcomes,
  - researcher objective status + next recommendations,
  - terminal outcomes,
  - watcher escalation alerts,
  - configured budgets/timeouts.
- Decision outputs:
  - dispatch capability call,
  - retry with adjusted objective/params,
  - spawn follow-up agenda item(s),
  - mark blocked,
  - mark complete.

All decision outputs must be recorded in `decision_log` using typed `ConductorDecision`.

### Phase C: Real Wake/Event Processing
`ProcessEvent` must become authoritative wake ingress:
- `WakePolicy::DisplayOnly`:
  - append telemetry/observability only.
- `WakePolicy::Wake`:
  - update run/call/item state from typed payload,
  - apply policy,
  - schedule/trigger `DispatchReady` when needed.

Required wake sources:
- conductor capability completion/failed/blocked events,
- watcher escalation events (`watcher.alert.*`) mapped into typed escalation handling.

### Phase D: Intelligent Capability Use
Conductor must use worker outputs semantically, not just success booleans.

Minimum behavior:
- Researcher:
  - use `objective_status`, `completion_reason`, `recommended_next_capability`, `recommended_next_objective` for next-step decisions.
- Terminal:
  - evaluate structured execution outcome and decide whether to retry/escalate/spawn follow-up.
- Both:
  - produce artifacts and link them to calls and agenda items.
  - receive natural-language objectives authored/refined by Conductor policy decisions.

### Phase E: Dispatch Engine
`DispatchReady` must:
- compute ready agenda items,
- mark selected items `Running` before dispatch,
- create/register capability calls with lineage,
- dispatch asynchronously,
- prevent duplicate dispatch for already running/terminal items,
- ingest results and feed them back into policy loop.

### Phase F: Terminal Run Resolution
When no active work remains, determine run terminal status from typed outcomes:
- `Completed` if objective satisfied,
- `Failed` if irrecoverable failure,
- `Blocked` if external dependency/user input required.

Emit final typed run outcome event(s).

### Phase G: Watcher Integration
Integrate watcher alert events into Conductor wake lane:
- map watcher typed review outputs to typed escalation signals,
- support LLM-driven watcher review over event-log windows,
- allow escalations to alter dispatch policy (retry delay, provider shift, capability switch, block).

No direct text parsing of alert prose for control decisions.

## Explicit Non-Goals
- Implementing full Prompt 04 writer patch-apply loop.
- Chat-specific orchestration hacks.
- Replacing typed contracts with prompt-only control flow.

## Acceptance Criteria
1. No deterministic worker-order workflow remains as orchestration authority.
2. Conductor dispatch decisions are policy-driven and recorded as typed decisions.
3. `ProcessEvent` enforces wake/display control boundaries and drives replanning.
4. `DispatchReady` performs real async dispatch with duplicate-dispatch protection.
5. Researcher and terminal outputs influence next-step decisions semantically.
6. Watcher alerts can wake Conductor and affect policy decisions.
7. Run reaches typed terminal status through loop convergence, not end-of-script behavior.
8. Conductor and Watcher BAML contracts are implemented and used in runtime policy paths.
9. Watcher runtime uses lower-power models than Conductor via model policy.

## Testing Requirements
Add tests that prove agentic behavior (not only non-panics):
- deterministic-plan regression guard:
  - verify conductor does not blindly execute fixed terminal->researcher order when signals indicate otherwise.
- baml contract regression guard:
  - verify Conductor and Watcher BAML outputs decode to typed Rust contracts without untyped control paths.
- decision-loop tests:
  - researcher returns `Incomplete` + recommendation -> conductor spawns follow-up agenda item.
  - watcher escalation wake event -> conductor alters next dispatch decision.
- failure-path tests:
  - simulate policy/model failure and verify explicit typed run failure/block result (no deterministic fallback execution).
- model policy tests:
  - verify watcher BAML calls resolve to lower-power model policy than Conductor BAML calls.
- dispatch tests:
  - no duplicate dispatch under repeated wake signals.
  - running->completed/failed/blocked transitions update agenda, calls, and decisions coherently.
- terminal status tests:
  - completion/failure/block convergence with no active work.

Add at least one integration-style test run:
`StartRun -> dispatch -> worker wake events -> replan -> follow-up dispatch -> terminal outcome`.

## Validation
Run and report exact commands:
- `cargo test -p sandbox --lib`
- `cargo test -p sandbox --lib conductor::actor -- --nocapture`
- `cargo test -p sandbox --lib conductor::state -- --nocapture`
- `cargo test -p sandbox --lib conductor::events -- --nocapture`

If watcher/event-stream integration changes surface externally, also run:
- `cargo test -p sandbox --test websocket_chat_test -- --nocapture`

## Final Summary Requirements
Include:
- files changed,
- deterministic workflow code removed/replaced,
- policy decision schema and transition table,
- one concrete event timeline showing replan behavior,
- tests run + outcomes,
- explicit remaining TODOs with rationale.
