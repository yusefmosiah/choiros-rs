# Prompt 03.5: Conductor Agentic Runtime Readiness (Before Writer Live Edit Loop)

You are working in `/Users/wiz/choiros-rs`.

## Narrative Summary (1-minute read)
Prompt 04 assumes Conductor is a real asynchronous orchestrator, not a fixed workflow runner. Before implementing Writer live edit loops, harden Conductor as the primary orchestration runtime for capability actors (`researcher`, `terminal`, `desktop`, `writer`, future apps), with typed wake triggers, rich non-waking telemetry, and UI streaming observability.

This prompt upgrades the runtime model and event contracts so 04 can plug in safely without introducing ad hoc control flow, Chat-specific hacks, or fragile polling-only behavior.

## What Changed
- Prompt 02 delivered Conductor MVP with typed request/response and worker delegation.
- Prompt 03 connected prompt bar to Conductor and writer auto-open.
- We identified architectural gaps:
  - Conductor remains partially predefined/linear.
  - Researcher behavior has been shallow in practice and needed explicit loop semantics.
  - Observability is incomplete for runtime decisions and live capability activity.
  - Wake-up policy and display-only telemetry are not cleanly separated.

## What To Do Next
Implement a strict Conductor runtime layer with:
- typed `run + agenda + capability calls + decisions + artifacts` model,
- wake-vs-display event lanes,
- async orchestration loop (dispatch without blocking + stream observation),
- desktop live event stream from prompt bar (display-only lane),
- stable contracts for 04 Writer prompt loop to attach to.

## Mission
Make Conductor the authoritative, long-lived orchestration runtime that can:
1. compose capability actors dynamically,
2. react only to explicit wake signals,
3. stream non-waking telemetry live to UI,
4. drive UI windows and editor/doc actions as capabilities,
5. support report follow-up prompts that continue the same run context.

Do this before implementing Prompt 04 writer patch application loop.

## Architecture Requirements (Non-Negotiable)

1. Conductor is orchestration authority for this lane (not ChatAgent).
2. No ad hoc string matching for control transitions.
3. All control flow and wake semantics are typed.
4. Capability actors remain long-lived; historical output is reusable context.
5. Wake lane and display lane are distinct contracts.
6. Backend-authoritative state model remains intact; no localStorage persistence for orchestration state.

## Read First
- `/Users/wiz/choiros-rs/AGENTS.md`
- `/Users/wiz/choiros-rs/docs/architecture/backend-authoritative-ui-state-pattern.md`
- `/Users/wiz/choiros-rs/docs/architecture/refactor-checklist-no-adhoc-workflow.md`
- `/Users/wiz/choiros-rs/sandbox/src/actors/conductor/`
- `/Users/wiz/choiros-rs/sandbox/src/actors/researcher.rs`
- `/Users/wiz/choiros-rs/sandbox/src/actors/terminal.rs`
- `/Users/wiz/choiros-rs/sandbox/src/supervisor/mod.rs`
- `/Users/wiz/choiros-rs/sandbox/src/api/logs.rs`
- `/Users/wiz/choiros-rs/dioxus-desktop/src/components/logs.rs`
- `/Users/wiz/choiros-rs/dioxus-desktop/src/desktop/components/prompt_bar.rs`
- `/Users/wiz/choiros-rs/shared-types/src/lib.rs`
- `/Users/wiz/choiros-rs/docs/prompts/04-writer-prompt-button-live-conductor-edits.md`

## Implement

### Phase A: Typed Runtime Model (No DAG Requirement)
Add/upgrade typed runtime structures in shared types and conductor internals:
- `ConductorRunState`:
  - `run_id`, `task_id`, `objective`, `status`, `created_at`, `updated_at`, `completed_at`
  - `agenda` (ordered pending work items)
  - `active_calls` (in-flight capability calls)
  - `artifacts` (typed output references)
  - `decision_log` (typed decisions)
- `ConductorAgendaItem`:
  - `item_id`, `capability`, `objective`, `priority`, `depends_on`, `status`
- `ConductorCapabilityCall`:
  - `call_id`, `capability`, `objective`, `status`, `started_at`, `completed_at`, `parent_call_id`
- `ConductorDecision`:
  - `dispatch`, `retry`, `spawn_followup`, `complete`, `block`

Use this as the runtime core. Do not force a static graph-first design.

### Phase B: Wake Lane vs Display Lane Contracts
Define typed event metadata fields (payload or event wrapper):
- `wake_policy`: `wake` | `display_only`
- `importance`: `low` | `normal` | `high`
- `run_id`, `task_id`, `call_id`, `capability`, `phase`

Wake lane should include:
- watcher escalation alerts,
- capability completion/failed/blocked transitions,
- explicit escalation signals.

Display-only lane should include:
- findings/learnings,
- tool calls/results,
- file operations,
- script execution snippets,
- interim progress.

### Phase C: Conductor Async Loop
Refactor Conductor execution to:
1. dispatch capability calls without blocking the entire runtime,
2. ingest streamed progress/events continuously,
3. apply typed decision policy from observed state,
4. stop only on explicit complete/blocked/failed decisions.

No hardcoded linear “terminal then researcher” assumptions.

### Phase D: Researcher as True Agentic Capability
Bring researcher behavior in line with terminal-style iterative capability behavior:
- respect typed step/round budgets,
- iterative rounds with query refinement,
- provider switching strategy for diversity,
- explicit objective completion/blocked outcomes.

Do not regress into default parallel “fan out all providers” in auto mode.

Add first-class typed `fetch_url` capability handling and ensure outputs are represented as typed artifacts usable by Conductor.

### Phase E: UI Orchestration Capability Surface
Add typed conductor-to-ui action contracts (through desktop/writer actors) for:
- open/focus window,
- open report/doc,
- route follow-up prompt from report context,
- future non-text app actions.

Do not implement full 04 patch application here. Just ensure runtime contracts support it cleanly.

### Phase F: Prompt Bar Live Event Stream (Star Wars Style)
Implement a UI stream that shows display-only telemetry lines rising from prompt bar:
- lines animate upward,
- scale down as they rise,
- fade out over TTL,
- no effect on conductor wake logic.

Use websocket/log stream source; do not add localStorage.

### Phase G: Runlog/Watcher Observability
Ensure run logs preserve both:
- chat legacy runs,
- conductor capability runs,
across reload and live streaming.

Runlog must keep conductor event families visible without remapping them into unrelated worker event types.

### Phase H: 04 Readiness Guardrails
Before declaring done, verify Prompt 04 prerequisites are now true:
- Conductor can run multi-round capability orchestration asynchronously.
- Wake/display event lane separation exists and is enforced.
- Researcher and terminal are both usable as agentic capability tools under Conductor.
- UI can consume live display-only stream without waking conductor.
- Typed contracts are stable for writer prompt loop integration.

## Explicit Non-Goals
- implementing full writer patch-apply loop from Prompt 04,
- replacing all ChatAgent lanes in this prompt,
- perfect planner intelligence,
- CRDT/collaborative editor semantics.

## Acceptance Criteria

1. Conductor runtime state tracks agenda + active calls + decisions + artifacts with typed contracts.
2. Wake lane events wake conductor; display-only lane events never wake conductor.
3. Researcher auto mode executes iterative rounds with typed stop conditions (complete/blocked/incomplete).
4. `fetch_url` exists as a typed researcher capability and returns normalized extract output.
5. Prompt bar displays live rising telemetry lines from display-only lane.
6. Logs/reload behavior preserves prior run visibility while continuing live stream.
7. No string-matching control authority is introduced.

## Validation

Prefer scoped commands. Avoid broad filtered runs that execute all integration binaries.

- `cargo check -p shared-types`
- `cargo check -p sandbox`
- `cargo check --manifest-path /Users/wiz/choiros-rs/dioxus-desktop/Cargo.toml`

Backend scoped tests (examples):
- `cargo test -p sandbox test_find_latest_seq --lib`
- `cargo test -p sandbox test_emit_task_completed --lib`
- `cargo test -p sandbox parse_provider_selection --lib`
- add/update focused conductor runtime tests:
  - wake-policy routing
  - async call lifecycle transitions
  - decision policy transitions
  - artifact/reference accumulation

Frontend scoped tests:
- prompt bar state transitions for toast/report paths,
- live telemetry stream enqueue/expire behavior,
- logs run derivation with conductor + chat coexistence.

Manual verification:
1. submit prompt via prompt bar,
2. observe live rising telemetry lines,
3. verify only wake events trigger conductor decisions,
4. verify report/toast outcomes remain typed,
5. reload logs page and confirm prior runs persist.

## Final Summary Requirements
Include:
- runtime model decisions made,
- wake/display lane mapping table,
- event sequence observed in one sample run,
- files changed,
- tests run with exact scoped commands.
