// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Synchronous BAML client with function-object pattern.

use crate::baml_client::{
    runtime::{get_runtime, FunctionOptions},
    stream_types, types,
};
use baml::{BamlEncode, BamlError, StreamingCall};

// =============================================================================
// Convenience Builder Methods Macro
// =============================================================================

/// Implements convenience builder methods that delegate to `with_options`.
/// Requires the type to have:
/// - `options: FunctionOptions` field
/// - `fn with_options(&self, options: FunctionOptions) -> Self` method
macro_rules! impl_options_convenience_methods {
    ($name:ident) => {
        impl $name {
            pub fn with_collector(&self, collector: &baml::Collector) -> Self {
                self.with_options(self.options.clone().with_collector(collector))
            }

            pub fn with_collectors(&self, collectors: &[baml::Collector]) -> Self {
                self.with_options(self.options.clone().with_collectors(collectors))
            }

            pub fn with_cancellation_token(&self, token: Option<baml::CancellationToken>) -> Self {
                self.with_options(self.options.clone().with_cancellation_token(token))
            }

            pub fn with_type_builder(&self, tb: &super::super::type_builder::TypeBuilder) -> Self {
                self.with_options(self.options.clone().with_type_builder(tb))
            }

            pub fn with_env_var(&self, key: impl Into<String>, value: impl Into<String>) -> Self {
                self.with_options(self.options.clone().with_env_var(key, value))
            }

            pub fn with_tag(&self, key: impl Into<String>, value: impl Into<String>) -> Self {
                self.with_options(self.options.clone().with_tag(key, value))
            }

            pub fn with_client(&self, client_name: impl Into<String>) -> Self {
                self.with_options(self.options.clone().with_client(client_name))
            }

            pub fn with_client_registry(&self, registry: &baml::ClientRegistry) -> Self {
                self.with_options(self.options.clone().with_client_registry(registry))
            }
        }
    };
}

// =============================================================================
// Function Struct Macro (generates per-function struct)
// =============================================================================

macro_rules! baml_function_sync {
    ($name:ident($($param:ident : $ptype:ty),* $(,)?) -> ($stream_ret:ty, $final_ret:ty)) => {
        #[derive(Clone)]
        pub struct $name {
            pub(crate) options: FunctionOptions,
        }

        impl Default for $name {
            fn default() -> Self {
                Self::new()
            }
        }

        impl $name {
            pub const fn new() -> Self {
                Self { options: FunctionOptions::new() }
            }

            fn with_options(&self, options: FunctionOptions) -> Self {
                Self { options }
            }

            // Terminal methods
            pub fn call(&self, $($param: $ptype),*) -> Result<$final_ret, BamlError> {
                let args = self.options.to_baml_args()
                    $(.arg(stringify!($param), $param.baml_encode()))*;
                get_runtime().call_function(stringify!($name), &args)
            }

            pub fn stream(&self, $($param: $ptype),*) -> Result<StreamingCall<$stream_ret, $final_ret>, BamlError> {
                let args = self.options.to_baml_args()
                    $(.arg(stringify!($param), $param.baml_encode()))*;
                get_runtime().call_function_stream(stringify!($name), &args)
            }

            pub fn parse(&self, response: &str) -> Result<$final_ret, BamlError> {
                get_runtime().parse(stringify!($name), response, false)
            }

            pub fn parse_stream(&self, response: &str) -> Result<$stream_ret, BamlError> {
                get_runtime().parse(stringify!($name), response, true)
            }
        }

        // Builder convenience methods (separate impl block via macro)
        impl_options_convenience_methods!($name);
    };
}

// =============================================================================
// Generate function structs
// =============================================================================

baml_function_sync!(ExtractResume(resume: impl AsRef<str> + BamlEncode, ) -> (stream_types::Resume, types::Resume));

baml_function_sync!(PlanAction(messages: &[types::Message], system_context: impl AsRef<str> + BamlEncode, available_tools: impl AsRef<str> + BamlEncode, ) -> (stream_types::AgentPlan, types::AgentPlan));

baml_function_sync!(QuickResponse(user_message: impl AsRef<str> + BamlEncode, conversation_history: impl AsRef<str> + BamlEncode, ) -> (String, String));

baml_function_sync!(SynthesizeResponse(user_prompt: impl AsRef<str> + BamlEncode, tool_results: &[types::ToolResult], conversation_context: impl AsRef<str> + BamlEncode, ) -> (String, String));

// =============================================================================
// Client Struct
// =============================================================================

#[derive(Clone)]
pub struct BamlSyncClient {
    options: FunctionOptions,

    pub ExtractResume: ExtractResume,

    pub PlanAction: PlanAction,

    pub QuickResponse: QuickResponse,

    pub SynthesizeResponse: SynthesizeResponse,
}

impl Default for BamlSyncClient {
    fn default() -> Self {
        Self::new()
    }
}

impl BamlSyncClient {
    pub const fn new() -> Self {
        Self {
            options: FunctionOptions::new(),

            ExtractResume: ExtractResume::new(),

            PlanAction: PlanAction::new(),

            QuickResponse: QuickResponse::new(),

            SynthesizeResponse: SynthesizeResponse::new(),
        }
    }

    /// Apply options to all functions. Returns a new client with the options set.
    pub fn with_options(&self, options: FunctionOptions) -> Self {
        Self {
            options: options.clone(),

            ExtractResume: ExtractResume {
                options: options.clone(),
            },

            PlanAction: PlanAction {
                options: options.clone(),
            },

            QuickResponse: QuickResponse {
                options: options.clone(),
            },

            SynthesizeResponse: SynthesizeResponse {
                options: options.clone(),
            },
        }
    }
}

// Builder convenience methods
impl_options_convenience_methods!(BamlSyncClient);

pub static B: BamlSyncClient = BamlSyncClient::new();
