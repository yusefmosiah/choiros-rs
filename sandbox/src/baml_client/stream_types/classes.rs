// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Generated streaming class types.
//!
//! These types are used during streaming to hold partial results.
//! Field types are already wrapped appropriately (Option, StreamState, etc.)

use super::*;
use crate::baml_client::types;
use baml::BamlDecode;

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct AgentDecision {



    pub tool_calls: Vec<Union8BashToolCallOrFetchUrlToolCallOrFileEditToolCallOrFileReadToolCallOrFileWriteToolCallOrFinishedToolCallOrMessageWriterToolCallOrWebSearchToolCall>,



    pub message: Option<String>,


}

impl AsRef<AgentDecision> for AgentDecision {
    fn as_ref(&self) -> &AgentDecision {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct AlternativeAction {
    pub action: Option<types::EscalationAction>,

    pub pros: Vec<String>,

    pub cons: Vec<String>,

    pub estimated_success_rate: Option<f64>,
}

impl AsRef<AlternativeAction> for AlternativeAction {
    fn as_ref(&self) -> &AlternativeAction {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct BashToolArgs {
    pub command: Option<String>,
}

impl AsRef<BashToolArgs> for BashToolArgs {
    fn as_ref(&self) -> &BashToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct BashToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<BashToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<BashToolCall> for BashToolCall {
    fn as_ref(&self) -> &BashToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorBootstrapInput {
    pub raw_objective: Option<String>,

    pub available_capabilities: Vec<String>,
}

impl AsRef<ConductorBootstrapInput> for ConductorBootstrapInput {
    fn as_ref(&self) -> &ConductorBootstrapInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorBootstrapOutput {
    pub dispatch_capabilities: Vec<String>,

    pub block_reason: Option<String>,

    pub rationale: Option<String>,

    pub confidence: Option<f64>,
}

impl AsRef<ConductorBootstrapOutput> for ConductorBootstrapOutput {
    fn as_ref(&self) -> &ConductorBootstrapOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorDecision {
    pub action: Option<types::ConductorAction>,

    pub args: Option<std::collections::HashMap<String, String>>,

    pub reason: Option<String>,
}

impl AsRef<ConductorDecision> for ConductorDecision {
    fn as_ref(&self) -> &ConductorDecision {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorDecisionInput {
    pub run_id: Option<String>,

    pub objective: Option<String>,

    pub document_path: Option<String>,

    pub last_error: Option<String>,
}

impl AsRef<ConductorDecisionInput> for ConductorDecisionInput {
    fn as_ref(&self) -> &ConductorDecisionInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorObjectiveRefineInput {
    pub raw_objective: Option<String>,

    pub context: Vec<String>,

    pub target_capability: Option<String>,
}

impl AsRef<ConductorObjectiveRefineInput> for ConductorObjectiveRefineInput {
    fn as_ref(&self) -> &ConductorObjectiveRefineInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorObjectiveRefineOutput {
    pub refined_objective: Option<String>,

    pub success_criteria: Vec<String>,

    pub estimated_steps: Option<i64>,

    pub confidence: Option<f64>,
}

impl AsRef<ConductorObjectiveRefineOutput> for ConductorObjectiveRefineOutput {
    fn as_ref(&self) -> &ConductorObjectiveRefineOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct DetectedAnomaly {
    pub anomaly_type: Option<String>,

    pub severity: Option<String>,

    pub description: Option<String>,

    pub affected_events: Vec<String>,

    pub pattern_detected: Option<String>,
}

impl AsRef<DetectedAnomaly> for DetectedAnomaly {
    fn as_ref(&self) -> &DetectedAnomaly {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FetchUrlToolArgs {
    pub path: Option<String>,
}

impl AsRef<FetchUrlToolArgs> for FetchUrlToolArgs {
    fn as_ref(&self) -> &FetchUrlToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FetchUrlToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<FetchUrlToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<FetchUrlToolCall> for FetchUrlToolCall {
    fn as_ref(&self) -> &FetchUrlToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileEditToolArgs {
    pub path: Option<String>,

    pub old_text: Option<String>,

    pub new_text: Option<String>,
}

impl AsRef<FileEditToolArgs> for FileEditToolArgs {
    fn as_ref(&self) -> &FileEditToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileEditToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<FileEditToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<FileEditToolCall> for FileEditToolCall {
    fn as_ref(&self) -> &FileEditToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileReadToolArgs {
    pub path: Option<String>,
}

impl AsRef<FileReadToolArgs> for FileReadToolArgs {
    fn as_ref(&self) -> &FileReadToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileReadToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<FileReadToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<FileReadToolCall> for FileReadToolCall {
    fn as_ref(&self) -> &FileReadToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileWriteToolArgs {
    pub path: Option<String>,

    pub content: Option<String>,
}

impl AsRef<FileWriteToolArgs> for FileWriteToolArgs {
    fn as_ref(&self) -> &FileWriteToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileWriteToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<FileWriteToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<FileWriteToolCall> for FileWriteToolCall {
    fn as_ref(&self) -> &FileWriteToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FinishedToolArgs {
    pub summary: Option<String>,
}

impl AsRef<FinishedToolArgs> for FinishedToolArgs {
    fn as_ref(&self) -> &FinishedToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FinishedToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<FinishedToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<FinishedToolCall> for FinishedToolCall {
    fn as_ref(&self) -> &FinishedToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct HistoricalResolution {
    pub pattern: Option<String>,

    pub successful_resolution: Option<String>,

    pub resolution_type: Option<String>,
}

impl AsRef<HistoricalResolution> for HistoricalResolution {
    fn as_ref(&self) -> &HistoricalResolution {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct Message {
    pub role: Option<String>,

    pub content: Option<String>,
}

impl AsRef<Message> for Message {
    fn as_ref(&self) -> &Message {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct MessageWriterToolArgs {
    pub content: Option<String>,

    pub mode: Option<String>,

    pub path: Option<String>,

    pub mode_arg: Option<String>,
}

impl AsRef<MessageWriterToolArgs> for MessageWriterToolArgs {
    fn as_ref(&self) -> &MessageWriterToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct MessageWriterToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<MessageWriterToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<MessageWriterToolCall> for MessageWriterToolCall {
    fn as_ref(&self) -> &MessageWriterToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ResearcherPlanInput {
    pub objective: Option<String>,

    pub current_query: Option<String>,

    pub round: Option<i64>,

    pub max_rounds: Option<i64>,

    pub working_draft_path: Option<String>,

    pub last_error: Option<String>,
}

impl AsRef<ResearcherPlanInput> for ResearcherPlanInput {
    fn as_ref(&self) -> &ResearcherPlanInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ResearcherPlanOutput {
    pub action: Option<types::ResearchAction>,

    pub query: Option<String>,

    pub provider: Option<String>,

    pub url: Option<String>,

    pub file_path: Option<String>,

    pub content: Option<String>,

    pub old_text: Option<String>,

    pub new_text: Option<String>,

    pub reason: Option<String>,

    pub status: Option<types::ResearchStatus>,
}

impl AsRef<ResearcherPlanOutput> for ResearcherPlanOutput {
    fn as_ref(&self) -> &ResearcherPlanOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct Resume {
    pub name: Option<String>,

    pub email: Option<String>,

    pub experience: Vec<String>,

    pub skills: Vec<String>,
}

impl AsRef<Resume> for Resume {
    fn as_ref(&self) -> &Resume {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ReviewScope {
    pub start_time: Option<String>,

    pub end_time: Option<String>,

    pub event_types: Vec<String>,

    pub min_level: Option<String>,
}

impl AsRef<ReviewScope> for ReviewScope {
    fn as_ref(&self) -> &ReviewScope {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct RiskItem {
    pub risk_id: Option<String>,

    pub category: Option<types::RiskCategory>,

    pub likelihood: Option<f64>,

    pub impact: Option<f64>,

    pub description: Option<String>,

    pub mitigating_factors: Vec<String>,
}

impl AsRef<RiskItem> for RiskItem {
    fn as_ref(&self) -> &RiskItem {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct RunStateSnapshot {
    pub run_id: Option<String>,

    pub status: Option<String>,

    pub active_call_count: Option<i64>,

    pub recent_failures: Option<i64>,

    pub elapsed_time_ms: Option<i64>,
}

impl AsRef<RunStateSnapshot> for RunStateSnapshot {
    fn as_ref(&self) -> &RunStateSnapshot {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct StreamChunk {
    pub chunk_type: Option<String>,

    pub content: Option<String>,
}

impl AsRef<StreamChunk> for StreamChunk {
    fn as_ref(&self) -> &StreamChunk {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ToolResult {
    pub tool_name: Option<String>,

    pub success: Option<bool>,

    pub output: Option<String>,

    pub error: Option<String>,
}

impl AsRef<ToolResult> for ToolResult {
    fn as_ref(&self) -> &ToolResult {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherEscalation {
    pub escalation_id: Option<String>,

    pub run_id: Option<String>,

    pub task_id: Option<String>,

    pub kind: Option<types::EscalationKind>,

    pub urgency: Option<types::UrgencyLevel>,

    pub affected_calls: Vec<String>,

    pub description: Option<String>,

    pub recommended_action: Option<String>,

    pub recommended_capability: Option<String>,

    pub recommended_objective: Option<String>,
}

impl AsRef<WatcherEscalation> for WatcherEscalation {
    fn as_ref(&self) -> &WatcherEscalation {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherEvent {
    pub event_id: Option<String>,

    pub timestamp: Option<String>,

    pub event_type: Option<String>,

    pub level: Option<String>,

    pub payload: Option<String>,

    pub source: Option<String>,
}

impl AsRef<WatcherEvent> for WatcherEvent {
    fn as_ref(&self) -> &WatcherEvent {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherLogWindowInput {
    pub window_id: Option<String>,

    pub run_id: Option<String>,

    pub task_id: Option<String>,

    pub events: Vec<WatcherEvent>,

    pub scope: Option<ReviewScope>,

    pub review_reason: Option<String>,
}

impl AsRef<WatcherLogWindowInput> for WatcherLogWindowInput {
    fn as_ref(&self) -> &WatcherLogWindowInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherMitigationInput {
    pub escalation: Option<WatcherEscalation>,

    pub run_state: Option<RunStateSnapshot>,

    pub available_capabilities: Vec<String>,

    pub historical_resolutions: Vec<HistoricalResolution>,
}

impl AsRef<WatcherMitigationInput> for WatcherMitigationInput {
    fn as_ref(&self) -> &WatcherMitigationInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherMitigationOutput {
    pub escalation_action: Option<types::EscalationAction>,

    pub urgency: Option<types::UrgencyLevel>,

    pub recommended_capability: Option<String>,

    pub recommended_objective: Option<String>,

    pub rationale: Option<String>,

    pub confidence: Option<f64>,

    pub expected_outcome: Option<String>,

    pub alternatives: Vec<AlternativeAction>,
}

impl AsRef<WatcherMitigationOutput> for WatcherMitigationOutput {
    fn as_ref(&self) -> &WatcherMitigationOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherReviewOutput {
    pub review_status: Option<types::ReviewStatus>,

    pub escalations: Vec<WatcherEscalation>,

    pub risks: Vec<RiskItem>,

    pub anomalies: Vec<DetectedAnomaly>,

    pub confidence: Option<f64>,

    pub rationale: Option<String>,
}

impl AsRef<WatcherReviewOutput> for WatcherReviewOutput {
    fn as_ref(&self) -> &WatcherReviewOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WebSearchToolArgs {
    pub query: Option<String>,
}

impl AsRef<WebSearchToolArgs> for WebSearchToolArgs {
    fn as_ref(&self) -> &WebSearchToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WebSearchToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<WebSearchToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<WebSearchToolCall> for WebSearchToolCall {
    fn as_ref(&self) -> &WebSearchToolCall {
        self
    }
}
