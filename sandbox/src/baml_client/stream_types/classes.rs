// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Generated streaming class types.
//!
//! These types are used during streaming to hold partial results.
//! Field types are already wrapped appropriately (Option, StreamState, etc.)

use super::*;
use crate::baml_client::types;
use baml::BamlDecode;

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct AgentDecision {



    pub tool_calls: Vec<Union8BashToolCallOrFetchUrlToolCallOrFileEditToolCallOrFileReadToolCallOrFileWriteToolCallOrFinishedToolCallOrMessageWriterToolCallOrWebSearchToolCall>,



    pub message: Option<String>,


}

impl AsRef<AgentDecision> for AgentDecision {
    fn as_ref(&self) -> &AgentDecision {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct AlternativeAction {
    pub action: Option<types::EscalationAction>,

    pub pros: Vec<String>,

    pub cons: Vec<String>,

    pub estimated_success_rate: Option<f64>,
}

impl AsRef<AlternativeAction> for AlternativeAction {
    fn as_ref(&self) -> &AlternativeAction {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct BashToolArgs {
    pub command: Option<String>,
}

impl AsRef<BashToolArgs> for BashToolArgs {
    fn as_ref(&self) -> &BashToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct BashToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<BashToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<BashToolCall> for BashToolCall {
    fn as_ref(&self) -> &BashToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ChangesetInput {
    pub patch_id: Option<String>,

    pub loop_id: Option<String>,

    pub before_content: Option<String>,

    pub after_content: Option<String>,

    pub ops_json: Option<String>,

    pub source: Option<String>,
}

impl AsRef<ChangesetInput> for ChangesetInput {
    fn as_ref(&self) -> &ChangesetInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ChangesetSummaryOutput {
    pub summary: Option<String>,

    pub impact: Option<types::ImpactLevel>,

    pub op_taxonomy: Vec<String>,
}

impl AsRef<ChangesetSummaryOutput> for ChangesetSummaryOutput {
    fn as_ref(&self) -> &ChangesetSummaryOutput {
        self
    }
}

/// A single citation proposed by the researcher or confirmed/rejected by the writer.

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct Citation {
    /// Artifact path, version_id, input_id, URL, or block_id.
    pub cited_id: Option<String>,

    pub cite_kind: Option<types::CitationKind>,

    pub confidence: Option<f64>,

    pub excerpt: Option<String>,

    pub rationale: Option<String>,
}

impl AsRef<Citation> for Citation {
    fn as_ref(&self) -> &Citation {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorBootstrapInput {
    pub raw_objective: Option<String>,

    pub available_capabilities: Vec<String>,
}

impl AsRef<ConductorBootstrapInput> for ConductorBootstrapInput {
    fn as_ref(&self) -> &ConductorBootstrapInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorBootstrapOutput {
    pub dispatch_capabilities: Vec<String>,

    pub block_reason: Option<String>,

    pub rationale: Option<String>,

    pub confidence: Option<f64>,
}

impl AsRef<ConductorBootstrapOutput> for ConductorBootstrapOutput {
    fn as_ref(&self) -> &ConductorBootstrapOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorDecision {
    pub action: Option<types::ConductorAction>,

    pub args: Option<std::collections::HashMap<String, String>>,

    pub reason: Option<String>,

    pub subharness_task: Option<String>,

    pub delegate_worker: Option<types::WorkerKind>,

    pub delegate_task: Option<String>,
}

impl AsRef<ConductorDecision> for ConductorDecision {
    fn as_ref(&self) -> &ConductorDecision {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorDecisionInput {
    pub run_id: Option<String>,

    pub objective: Option<String>,

    pub document_path: Option<String>,

    pub last_error: Option<String>,
}

impl AsRef<ConductorDecisionInput> for ConductorDecisionInput {
    fn as_ref(&self) -> &ConductorDecisionInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorObjectiveRefineInput {
    pub raw_objective: Option<String>,

    pub context: Vec<String>,

    pub target_capability: Option<String>,
}

impl AsRef<ConductorObjectiveRefineInput> for ConductorObjectiveRefineInput {
    fn as_ref(&self) -> &ConductorObjectiveRefineInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ConductorObjectiveRefineOutput {
    pub refined_objective: Option<String>,

    pub success_criteria: Vec<String>,

    pub estimated_steps: Option<i64>,

    pub confidence: Option<f64>,
}

impl AsRef<ConductorObjectiveRefineOutput> for ConductorObjectiveRefineOutput {
    fn as_ref(&self) -> &ConductorObjectiveRefineOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ContextSource {
    pub kind: Option<types::ContextSourceKind>,

    pub source_ref: Option<String>,

    pub rationale: Option<String>,

    pub max_tokens: Option<i64>,
}

impl AsRef<ContextSource> for ContextSource {
    fn as_ref(&self) -> &ContextSource {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct DagStep {
    /// Unique identifier for this step within the DAG. Other steps reference
    /// this via ${id} in their arguments.
    pub id: Option<String>,

    /// The operation to perform.
    pub op: Option<types::StepOp>,

    /// Step IDs that must complete before this step runs. The harness
    /// enforces topological ordering. Empty = no dependencies (runs first).
    pub depends_on: Vec<String>,

    /// If set, this step only executes when the named Gate step evaluated
    /// to true. Skipped steps produce output "(skipped)".
    pub condition: Option<String>,

    /// For ToolCall: the tool name (bash, file_read, etc.)
    pub tool_name: Option<String>,

    pub tool_args: Option<std::collections::HashMap<String, String>>,

    /// For LlmCall: the prompt to send. Can contain ${step_id} refs.
    pub prompt: Option<String>,

    pub model_hint: Option<String>,

    pub system_prompt: Option<String>,

    /// For Transform: the operation. Supported: "regex", "truncate",
    /// "json_extract", "template".
    pub transform_op: Option<String>,

    pub transform_input: Option<String>,

    pub transform_pattern: Option<String>,

    /// For Gate: the predicate to evaluate. Format: "op:value" where op
    /// is one of contains, not_contains, matches, equals, not_equals.
    /// The input is the output of the first dependency.
    pub gate_predicate: Option<String>,

    /// For Emit: the message to send to the parent. Can contain ${refs}.
    pub emit_message: Option<String>,

    /// For Eval: the Rhai script source code.
    /// Prior step outputs can be accessed via step_output("id") or via
    /// variables pre-injected by listing their step IDs in `eval_inputs`.
    pub eval_code: Option<String>,

    pub eval_inputs: Option<Vec<String>>,

    /// Human-readable description of what this step does (for tracing).
    pub description: Option<String>,
}

impl AsRef<DagStep> for DagStep {
    fn as_ref(&self) -> &DagStep {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct DetectedAnomaly {
    pub anomaly_type: Option<String>,

    pub severity: Option<String>,

    pub description: Option<String>,

    pub affected_events: Vec<String>,

    pub pattern_detected: Option<String>,
}

impl AsRef<DetectedAnomaly> for DetectedAnomaly {
    fn as_ref(&self) -> &DetectedAnomaly {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FanOutBranch {
    /// Objective for this branch
    pub objective: Option<String>,

    pub model_hint: Option<String>,

    pub context_seed: Option<String>,
}

impl AsRef<FanOutBranch> for FanOutBranch {
    fn as_ref(&self) -> &FanOutBranch {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FetchUrlToolArgs {
    pub path: Option<String>,
}

impl AsRef<FetchUrlToolArgs> for FetchUrlToolArgs {
    fn as_ref(&self) -> &FetchUrlToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FetchUrlToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<FetchUrlToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<FetchUrlToolCall> for FetchUrlToolCall {
    fn as_ref(&self) -> &FetchUrlToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileEditToolArgs {
    pub path: Option<String>,

    pub old_text: Option<String>,

    pub new_text: Option<String>,
}

impl AsRef<FileEditToolArgs> for FileEditToolArgs {
    fn as_ref(&self) -> &FileEditToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileEditToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<FileEditToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<FileEditToolCall> for FileEditToolCall {
    fn as_ref(&self) -> &FileEditToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileReadToolArgs {
    pub path: Option<String>,
}

impl AsRef<FileReadToolArgs> for FileReadToolArgs {
    fn as_ref(&self) -> &FileReadToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileReadToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<FileReadToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<FileReadToolCall> for FileReadToolCall {
    fn as_ref(&self) -> &FileReadToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileWriteToolArgs {
    pub path: Option<String>,

    pub content: Option<String>,
}

impl AsRef<FileWriteToolArgs> for FileWriteToolArgs {
    fn as_ref(&self) -> &FileWriteToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FileWriteToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<FileWriteToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<FileWriteToolCall> for FileWriteToolCall {
    fn as_ref(&self) -> &FileWriteToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FinishedToolArgs {
    pub summary: Option<String>,
}

impl AsRef<FinishedToolArgs> for FinishedToolArgs {
    fn as_ref(&self) -> &FinishedToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct FinishedToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<FinishedToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<FinishedToolCall> for FinishedToolCall {
    fn as_ref(&self) -> &FinishedToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct HistoricalResolution {
    pub pattern: Option<String>,

    pub successful_resolution: Option<String>,

    pub resolution_type: Option<String>,
}

impl AsRef<HistoricalResolution> for HistoricalResolution {
    fn as_ref(&self) -> &HistoricalResolution {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct Message {
    pub role: Option<String>,

    pub content: Option<String>,
}

impl AsRef<Message> for Message {
    fn as_ref(&self) -> &Message {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct MessageWriterToolArgs {
    pub content: Option<String>,

    pub mode: Option<String>,

    pub path: Option<String>,

    pub mode_arg: Option<String>,
}

impl AsRef<MessageWriterToolArgs> for MessageWriterToolArgs {
    fn as_ref(&self) -> &MessageWriterToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct MessageWriterToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<MessageWriterToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<MessageWriterToolCall> for MessageWriterToolCall {
    fn as_ref(&self) -> &MessageWriterToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct NextAction {
    pub kind: Option<types::NextActionKind>,

    pub reason: Option<String>,

    pub tool_calls: Option<Vec<ToolCallSpec>>,

    pub program: Option<Vec<DagStep>>,

    pub branches: Option<Vec<FanOutBranch>>,

    pub recurse: Option<RecurseSpec>,
}

impl AsRef<NextAction> for NextAction {
    fn as_ref(&self) -> &NextAction {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct RecurseSpec {
    /// Objective for the sub-harness
    pub objective: Option<String>,

    pub context_seed: Option<String>,

    pub model_hint: Option<String>,

    pub max_steps: Option<i64>,
}

impl AsRef<RecurseSpec> for RecurseSpec {
    fn as_ref(&self) -> &RecurseSpec {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ResearcherPlanInput {
    pub objective: Option<String>,

    pub current_query: Option<String>,

    pub round: Option<i64>,

    pub max_rounds: Option<i64>,

    pub working_draft_path: Option<String>,

    pub last_error: Option<String>,
}

impl AsRef<ResearcherPlanInput> for ResearcherPlanInput {
    fn as_ref(&self) -> &ResearcherPlanInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ResearcherPlanOutput {
    pub action: Option<types::ResearchAction>,

    pub query: Option<String>,

    pub provider: Option<String>,

    pub url: Option<String>,

    pub file_path: Option<String>,

    pub content: Option<String>,

    pub old_text: Option<String>,

    pub new_text: Option<String>,

    pub reason: Option<String>,

    pub status: Option<types::ResearchStatus>,
}

impl AsRef<ResearcherPlanOutput> for ResearcherPlanOutput {
    fn as_ref(&self) -> &ResearcherPlanOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct Resume {
    pub name: Option<String>,

    pub email: Option<String>,

    pub experience: Vec<String>,

    pub skills: Vec<String>,
}

impl AsRef<Resume> for Resume {
    fn as_ref(&self) -> &Resume {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ReviewScope {
    pub start_time: Option<String>,

    pub end_time: Option<String>,

    pub event_types: Vec<String>,

    pub min_level: Option<String>,
}

impl AsRef<ReviewScope> for ReviewScope {
    fn as_ref(&self) -> &ReviewScope {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct RiskItem {
    pub risk_id: Option<String>,

    pub category: Option<types::RiskCategory>,

    pub likelihood: Option<f64>,

    pub impact: Option<f64>,

    pub description: Option<String>,

    pub mitigating_factors: Vec<String>,
}

impl AsRef<RiskItem> for RiskItem {
    fn as_ref(&self) -> &RiskItem {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct RlmTurn {
    /// What context to load for this turn. The harness resolves these into text.
    /// Empty sources = the model is working from working_memory alone.
    pub sources: Vec<ContextSource>,

    /// The model's articulation of its current reasoning state.
    /// This carries focus across turns. It is ephemeral â€” rewritten each turn.
    /// This IS the metacognition: the model reflecting on what it knows,
    /// what it's uncertain about, and what it needs next.
    pub working_memory: Option<String>,

    /// What to do next. The harness executes this.
    pub next_action: Option<NextAction>,
}

impl AsRef<RlmTurn> for RlmTurn {
    fn as_ref(&self) -> &RlmTurn {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct RlmTurnContext {
    /// The original objective (constant across turns)
    pub objective: Option<String>,

    pub turn_number: Option<i64>,

    pub max_turns: Option<i64>,

    pub previous_working_memory: Option<String>,

    pub assembled_context: Option<String>,

    pub action_results: Option<String>,

    pub turn_history_summary: Option<String>,
}

impl AsRef<RlmTurnContext> for RlmTurnContext {
    fn as_ref(&self) -> &RlmTurnContext {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct RunStateSnapshot {
    pub run_id: Option<String>,

    pub status: Option<String>,

    pub active_call_count: Option<i64>,

    pub recent_failures: Option<i64>,

    pub elapsed_time_ms: Option<i64>,
}

impl AsRef<RunStateSnapshot> for RunStateSnapshot {
    fn as_ref(&self) -> &RunStateSnapshot {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct StreamChunk {
    pub chunk_type: Option<String>,

    pub content: Option<String>,
}

impl AsRef<StreamChunk> for StreamChunk {
    fn as_ref(&self) -> &StreamChunk {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ToolCallSpec {
    pub tool_name: Option<String>,

    pub tool_args: std::collections::HashMap<String, String>,

    pub reasoning: Option<String>,
}

impl AsRef<ToolCallSpec> for ToolCallSpec {
    fn as_ref(&self) -> &ToolCallSpec {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct ToolResult {
    pub tool_name: Option<String>,

    pub success: Option<bool>,

    pub output: Option<String>,

    pub error: Option<String>,
}

impl AsRef<ToolResult> for ToolResult {
    fn as_ref(&self) -> &ToolResult {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherEscalation {
    pub escalation_id: Option<String>,

    pub run_id: Option<String>,

    pub task_id: Option<String>,

    pub kind: Option<types::EscalationKind>,

    pub urgency: Option<types::UrgencyLevel>,

    pub affected_calls: Vec<String>,

    pub description: Option<String>,

    pub recommended_action: Option<String>,

    pub recommended_capability: Option<String>,

    pub recommended_objective: Option<String>,
}

impl AsRef<WatcherEscalation> for WatcherEscalation {
    fn as_ref(&self) -> &WatcherEscalation {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherEvent {
    pub event_id: Option<String>,

    pub timestamp: Option<String>,

    pub event_type: Option<String>,

    pub level: Option<String>,

    pub payload: Option<String>,

    pub source: Option<String>,
}

impl AsRef<WatcherEvent> for WatcherEvent {
    fn as_ref(&self) -> &WatcherEvent {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherLogWindowInput {
    pub window_id: Option<String>,

    pub run_id: Option<String>,

    pub task_id: Option<String>,

    pub events: Vec<WatcherEvent>,

    pub scope: Option<ReviewScope>,

    pub review_reason: Option<String>,
}

impl AsRef<WatcherLogWindowInput> for WatcherLogWindowInput {
    fn as_ref(&self) -> &WatcherLogWindowInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherMitigationInput {
    pub escalation: Option<WatcherEscalation>,

    pub run_state: Option<RunStateSnapshot>,

    pub available_capabilities: Vec<String>,

    pub historical_resolutions: Vec<HistoricalResolution>,
}

impl AsRef<WatcherMitigationInput> for WatcherMitigationInput {
    fn as_ref(&self) -> &WatcherMitigationInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherMitigationOutput {
    pub escalation_action: Option<types::EscalationAction>,

    pub urgency: Option<types::UrgencyLevel>,

    pub recommended_capability: Option<String>,

    pub recommended_objective: Option<String>,

    pub rationale: Option<String>,

    pub confidence: Option<f64>,

    pub expected_outcome: Option<String>,

    pub alternatives: Vec<AlternativeAction>,
}

impl AsRef<WatcherMitigationOutput> for WatcherMitigationOutput {
    fn as_ref(&self) -> &WatcherMitigationOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WatcherReviewOutput {
    pub review_status: Option<types::ReviewStatus>,

    pub escalations: Vec<WatcherEscalation>,

    pub risks: Vec<RiskItem>,

    pub anomalies: Vec<DetectedAnomaly>,

    pub confidence: Option<f64>,

    pub rationale: Option<String>,
}

impl AsRef<WatcherReviewOutput> for WatcherReviewOutput {
    fn as_ref(&self) -> &WatcherReviewOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WebSearchToolArgs {
    pub query: Option<String>,
}

impl AsRef<WebSearchToolArgs> for WebSearchToolArgs {
    fn as_ref(&self) -> &WebSearchToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlDecode)]

pub struct WebSearchToolCall {
    pub tool_name: Option<String>,

    pub tool_args: Option<WebSearchToolArgs>,

    pub reasoning: Option<String>,
}

impl AsRef<WebSearchToolCall> for WebSearchToolCall {
    fn as_ref(&self) -> &WebSearchToolCall {
        self
    }
}
