// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Generated class builder wrappers for type-safe field access.


/// Wrapper for the `AgentPlan` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentPlanClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentPlanClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("AgentPlan is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `thinking` field builder.
    pub fn property_thinking(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("thinking")
            .expect("AgentPlan.thinking is statically defined in .baml and should always be present")
    }


    /// Access the `tool_calls` field builder.
    pub fn property_tool_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_calls")
            .expect("AgentPlan.tool_calls is statically defined in .baml and should always be present")
    }


    /// Access the `final_response` field builder.
    pub fn property_final_response(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("final_response")
            .expect("AgentPlan.final_response is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("AgentPlan.confidence is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `AgentToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("AgentToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `bash` field builder.
    pub fn property_bash(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("bash")
            .expect("AgentToolArgs.bash is statically defined in .baml and should always be present")
    }


    /// Access the `read_file` field builder.
    pub fn property_read_file(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("read_file")
            .expect("AgentToolArgs.read_file is statically defined in .baml and should always be present")
    }


    /// Access the `write_file` field builder.
    pub fn property_write_file(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("write_file")
            .expect("AgentToolArgs.write_file is statically defined in .baml and should always be present")
    }


    /// Access the `list_files` field builder.
    pub fn property_list_files(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("list_files")
            .expect("AgentToolArgs.list_files is statically defined in .baml and should always be present")
    }


    /// Access the `search_files` field builder.
    pub fn property_search_files(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("search_files")
            .expect("AgentToolArgs.search_files is statically defined in .baml and should always be present")
    }


    /// Access the `command` field builder.
    pub fn property_command(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("command")
            .expect("AgentToolArgs.command is statically defined in .baml and should always be present")
    }


    /// Access the `cmd` field builder.
    pub fn property_cmd(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("cmd")
            .expect("AgentToolArgs.cmd is statically defined in .baml and should always be present")
    }


    /// Access the `cwd` field builder.
    pub fn property_cwd(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("cwd")
            .expect("AgentToolArgs.cwd is statically defined in .baml and should always be present")
    }


    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning")
            .expect("AgentToolArgs.reasoning is statically defined in .baml and should always be present")
    }


    /// Access the `timeout_ms` field builder.
    pub fn property_timeout_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timeout_ms")
            .expect("AgentToolArgs.timeout_ms is statically defined in .baml and should always be present")
    }


    /// Access the `model` field builder.
    pub fn property_model(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("model")
            .expect("AgentToolArgs.model is statically defined in .baml and should always be present")
    }


    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path")
            .expect("AgentToolArgs.path is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("AgentToolArgs.content is statically defined in .baml and should always be present")
    }


    /// Access the `pattern` field builder.
    pub fn property_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pattern")
            .expect("AgentToolArgs.pattern is statically defined in .baml and should always be present")
    }


    /// Access the `file_pattern` field builder.
    pub fn property_file_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("file_pattern")
            .expect("AgentToolArgs.file_pattern is statically defined in .baml and should always be present")
    }


    /// Access the `recursive` field builder.
    pub fn property_recursive(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recursive")
            .expect("AgentToolArgs.recursive is statically defined in .baml and should always be present")
    }


    /// Access the `limit` field builder.
    pub fn property_limit(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("limit")
            .expect("AgentToolArgs.limit is statically defined in .baml and should always be present")
    }


    /// Access the `offset` field builder.
    pub fn property_offset(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("offset")
            .expect("AgentToolArgs.offset is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `AgentToolCall` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentToolCallClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentToolCallClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("AgentToolCall is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `tool_name` field builder.
    pub fn property_tool_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_name")
            .expect("AgentToolCall.tool_name is statically defined in .baml and should always be present")
    }


    /// Access the `tool_args` field builder.
    pub fn property_tool_args(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_args")
            .expect("AgentToolCall.tool_args is statically defined in .baml and should always be present")
    }


    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning")
            .expect("AgentToolCall.reasoning is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `BashToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct BashToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl BashToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("BashToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `command` field builder.
    pub fn property_command(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("command")
            .expect("BashToolArgs.command is statically defined in .baml and should always be present")
    }


    /// Access the `cmd` field builder.
    pub fn property_cmd(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("cmd")
            .expect("BashToolArgs.cmd is statically defined in .baml and should always be present")
    }


    /// Access the `cwd` field builder.
    pub fn property_cwd(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("cwd")
            .expect("BashToolArgs.cwd is statically defined in .baml and should always be present")
    }


    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning")
            .expect("BashToolArgs.reasoning is statically defined in .baml and should always be present")
    }


    /// Access the `timeout_ms` field builder.
    pub fn property_timeout_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timeout_ms")
            .expect("BashToolArgs.timeout_ms is statically defined in .baml and should always be present")
    }


    /// Access the `model` field builder.
    pub fn property_model(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("model")
            .expect("BashToolArgs.model is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ListFilesToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ListFilesToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl ListFilesToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ListFilesToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path")
            .expect("ListFilesToolArgs.path is statically defined in .baml and should always be present")
    }


    /// Access the `recursive` field builder.
    pub fn property_recursive(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recursive")
            .expect("ListFilesToolArgs.recursive is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `Message` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct MessageClassBuilder {
    inner: baml::ClassBuilder,
}

impl MessageClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("Message is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `role` field builder.
    pub fn property_role(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("role")
            .expect("Message.role is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("Message.content is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ReadFileToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ReadFileToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl ReadFileToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ReadFileToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path")
            .expect("ReadFileToolArgs.path is statically defined in .baml and should always be present")
    }


    /// Access the `limit` field builder.
    pub fn property_limit(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("limit")
            .expect("ReadFileToolArgs.limit is statically defined in .baml and should always be present")
    }


    /// Access the `offset` field builder.
    pub fn property_offset(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("offset")
            .expect("ReadFileToolArgs.offset is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `Resume` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResumeClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResumeClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("Resume is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("name")
            .expect("Resume.name is statically defined in .baml and should always be present")
    }


    /// Access the `email` field builder.
    pub fn property_email(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("email")
            .expect("Resume.email is statically defined in .baml and should always be present")
    }


    /// Access the `experience` field builder.
    pub fn property_experience(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("experience")
            .expect("Resume.experience is statically defined in .baml and should always be present")
    }


    /// Access the `skills` field builder.
    pub fn property_skills(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("skills")
            .expect("Resume.skills is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `SearchFilesToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct SearchFilesToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl SearchFilesToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("SearchFilesToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `pattern` field builder.
    pub fn property_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pattern")
            .expect("SearchFilesToolArgs.pattern is statically defined in .baml and should always be present")
    }


    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path")
            .expect("SearchFilesToolArgs.path is statically defined in .baml and should always be present")
    }


    /// Access the `file_pattern` field builder.
    pub fn property_file_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("file_pattern")
            .expect("SearchFilesToolArgs.file_pattern is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `StreamChunk` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct StreamChunkClassBuilder {
    inner: baml::ClassBuilder,
}

impl StreamChunkClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("StreamChunk is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `chunk_type` field builder.
    pub fn property_chunk_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("chunk_type")
            .expect("StreamChunk.chunk_type is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("StreamChunk.content is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ToolResult` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ToolResultClassBuilder {
    inner: baml::ClassBuilder,
}

impl ToolResultClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ToolResult is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `tool_name` field builder.
    pub fn property_tool_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_name")
            .expect("ToolResult.tool_name is statically defined in .baml and should always be present")
    }


    /// Access the `success` field builder.
    pub fn property_success(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("success")
            .expect("ToolResult.success is statically defined in .baml and should always be present")
    }


    /// Access the `output` field builder.
    pub fn property_output(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("output")
            .expect("ToolResult.output is statically defined in .baml and should always be present")
    }


    /// Access the `error` field builder.
    pub fn property_error(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("error")
            .expect("ToolResult.error is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `WriteFileToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WriteFileToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl WriteFileToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("WriteFileToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path")
            .expect("WriteFileToolArgs.path is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("WriteFileToolArgs.content is statically defined in .baml and should always be present")
    }

}

