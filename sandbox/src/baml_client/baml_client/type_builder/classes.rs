// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Generated class builder wrappers for type-safe field access.


/// Wrapper for the `AgentPlan` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentPlanClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentPlanClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("AgentPlan is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `thinking` field builder.
    pub fn property_thinking(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("thinking")
            .expect("AgentPlan.thinking is statically defined in .baml and should always be present")
    }


    /// Access the `tool_calls` field builder.
    pub fn property_tool_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_calls")
            .expect("AgentPlan.tool_calls is statically defined in .baml and should always be present")
    }


    /// Access the `final_response` field builder.
    pub fn property_final_response(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("final_response")
            .expect("AgentPlan.final_response is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("AgentPlan.confidence is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `AgentToolCall` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentToolCallClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentToolCallClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("AgentToolCall is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `tool_name` field builder.
    pub fn property_tool_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_name")
            .expect("AgentToolCall.tool_name is statically defined in .baml and should always be present")
    }


    /// Access the `tool_args` field builder.
    pub fn property_tool_args(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_args")
            .expect("AgentToolCall.tool_args is statically defined in .baml and should always be present")
    }


    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning")
            .expect("AgentToolCall.reasoning is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `Message` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct MessageClassBuilder {
    inner: baml::ClassBuilder,
}

impl MessageClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("Message is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `role` field builder.
    pub fn property_role(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("role")
            .expect("Message.role is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("Message.content is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `Resume` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResumeClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResumeClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("Resume is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("name")
            .expect("Resume.name is statically defined in .baml and should always be present")
    }


    /// Access the `email` field builder.
    pub fn property_email(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("email")
            .expect("Resume.email is statically defined in .baml and should always be present")
    }


    /// Access the `experience` field builder.
    pub fn property_experience(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("experience")
            .expect("Resume.experience is statically defined in .baml and should always be present")
    }


    /// Access the `skills` field builder.
    pub fn property_skills(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("skills")
            .expect("Resume.skills is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `StreamChunk` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct StreamChunkClassBuilder {
    inner: baml::ClassBuilder,
}

impl StreamChunkClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("StreamChunk is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `chunk_type` field builder.
    pub fn property_chunk_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("chunk_type")
            .expect("StreamChunk.chunk_type is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("StreamChunk.content is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ToolResult` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ToolResultClassBuilder {
    inner: baml::ClassBuilder,
}

impl ToolResultClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ToolResult is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `tool_name` field builder.
    pub fn property_tool_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_name")
            .expect("ToolResult.tool_name is statically defined in .baml and should always be present")
    }


    /// Access the `success` field builder.
    pub fn property_success(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("success")
            .expect("ToolResult.success is statically defined in .baml and should always be present")
    }


    /// Access the `output` field builder.
    pub fn property_output(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("output")
            .expect("ToolResult.output is statically defined in .baml and should always be present")
    }


    /// Access the `error` field builder.
    pub fn property_error(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("error")
            .expect("ToolResult.error is statically defined in .baml and should always be present")
    }

}

