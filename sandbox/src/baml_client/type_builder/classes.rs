// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Generated class builder wrappers for type-safe field access.


/// Wrapper for the `AgentPlan` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentPlanClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentPlanClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("AgentPlan is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `thinking` field builder.
    pub fn property_thinking(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("thinking")
            .expect("AgentPlan.thinking is statically defined in .baml and should always be present")
    }


    /// Access the `tool_calls` field builder.
    pub fn property_tool_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_calls")
            .expect("AgentPlan.tool_calls is statically defined in .baml and should always be present")
    }


    /// Access the `final_response` field builder.
    pub fn property_final_response(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("final_response")
            .expect("AgentPlan.final_response is statically defined in .baml and should always be present")
    }


    /// Access the `objective_status` field builder.
    pub fn property_objective_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective_status")
            .expect("AgentPlan.objective_status is statically defined in .baml and should always be present")
    }


    /// Access the `plan_mode` field builder.
    pub fn property_plan_mode(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("plan_mode")
            .expect("AgentPlan.plan_mode is statically defined in .baml and should always be present")
    }


    /// Access the `completion_reason` field builder.
    pub fn property_completion_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("completion_reason")
            .expect("AgentPlan.completion_reason is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("AgentPlan.confidence is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `AgentToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("AgentToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `bash` field builder.
    pub fn property_bash(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("bash")
            .expect("AgentToolArgs.bash is statically defined in .baml and should always be present")
    }


    /// Access the `read_file` field builder.
    pub fn property_read_file(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("read_file")
            .expect("AgentToolArgs.read_file is statically defined in .baml and should always be present")
    }


    /// Access the `write_file` field builder.
    pub fn property_write_file(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("write_file")
            .expect("AgentToolArgs.write_file is statically defined in .baml and should always be present")
    }


    /// Access the `list_files` field builder.
    pub fn property_list_files(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("list_files")
            .expect("AgentToolArgs.list_files is statically defined in .baml and should always be present")
    }


    /// Access the `search_files` field builder.
    pub fn property_search_files(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("search_files")
            .expect("AgentToolArgs.search_files is statically defined in .baml and should always be present")
    }


    /// Access the `web_search` field builder.
    pub fn property_web_search(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("web_search")
            .expect("AgentToolArgs.web_search is statically defined in .baml and should always be present")
    }


    /// Access the `command` field builder.
    pub fn property_command(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("command")
            .expect("AgentToolArgs.command is statically defined in .baml and should always be present")
    }


    /// Access the `cmd` field builder.
    pub fn property_cmd(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("cmd")
            .expect("AgentToolArgs.cmd is statically defined in .baml and should always be present")
    }


    /// Access the `cwd` field builder.
    pub fn property_cwd(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("cwd")
            .expect("AgentToolArgs.cwd is statically defined in .baml and should always be present")
    }


    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning")
            .expect("AgentToolArgs.reasoning is statically defined in .baml and should always be present")
    }


    /// Access the `timeout_ms` field builder.
    pub fn property_timeout_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timeout_ms")
            .expect("AgentToolArgs.timeout_ms is statically defined in .baml and should always be present")
    }


    /// Access the `model` field builder.
    pub fn property_model(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("model")
            .expect("AgentToolArgs.model is statically defined in .baml and should always be present")
    }


    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path")
            .expect("AgentToolArgs.path is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("AgentToolArgs.content is statically defined in .baml and should always be present")
    }


    /// Access the `pattern` field builder.
    pub fn property_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pattern")
            .expect("AgentToolArgs.pattern is statically defined in .baml and should always be present")
    }


    /// Access the `file_pattern` field builder.
    pub fn property_file_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("file_pattern")
            .expect("AgentToolArgs.file_pattern is statically defined in .baml and should always be present")
    }


    /// Access the `recursive` field builder.
    pub fn property_recursive(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recursive")
            .expect("AgentToolArgs.recursive is statically defined in .baml and should always be present")
    }


    /// Access the `limit` field builder.
    pub fn property_limit(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("limit")
            .expect("AgentToolArgs.limit is statically defined in .baml and should always be present")
    }


    /// Access the `offset` field builder.
    pub fn property_offset(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("offset")
            .expect("AgentToolArgs.offset is statically defined in .baml and should always be present")
    }


    /// Access the `query` field builder.
    pub fn property_query(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("query")
            .expect("AgentToolArgs.query is statically defined in .baml and should always be present")
    }


    /// Access the `provider` field builder.
    pub fn property_provider(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider")
            .expect("AgentToolArgs.provider is statically defined in .baml and should always be present")
    }


    /// Access the `max_results` field builder.
    pub fn property_max_results(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("max_results")
            .expect("AgentToolArgs.max_results is statically defined in .baml and should always be present")
    }


    /// Access the `time_range` field builder.
    pub fn property_time_range(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("time_range")
            .expect("AgentToolArgs.time_range is statically defined in .baml and should always be present")
    }


    /// Access the `include_domains` field builder.
    pub fn property_include_domains(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("include_domains")
            .expect("AgentToolArgs.include_domains is statically defined in .baml and should always be present")
    }


    /// Access the `exclude_domains` field builder.
    pub fn property_exclude_domains(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("exclude_domains")
            .expect("AgentToolArgs.exclude_domains is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `AgentToolCall` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentToolCallClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentToolCallClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("AgentToolCall is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `tool_name` field builder.
    pub fn property_tool_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_name")
            .expect("AgentToolCall.tool_name is statically defined in .baml and should always be present")
    }


    /// Access the `tool_args` field builder.
    pub fn property_tool_args(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_args")
            .expect("AgentToolCall.tool_args is statically defined in .baml and should always be present")
    }


    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning")
            .expect("AgentToolCall.reasoning is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `AlternativeAction` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AlternativeActionClassBuilder {
    inner: baml::ClassBuilder,
}

impl AlternativeActionClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("AlternativeAction is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `action` field builder.
    pub fn property_action(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("action")
            .expect("AlternativeAction.action is statically defined in .baml and should always be present")
    }


    /// Access the `pros` field builder.
    pub fn property_pros(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pros")
            .expect("AlternativeAction.pros is statically defined in .baml and should always be present")
    }


    /// Access the `cons` field builder.
    pub fn property_cons(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("cons")
            .expect("AlternativeAction.cons is statically defined in .baml and should always be present")
    }


    /// Access the `estimated_success_rate` field builder.
    pub fn property_estimated_success_rate(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("estimated_success_rate")
            .expect("AlternativeAction.estimated_success_rate is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `BashToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct BashToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl BashToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("BashToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `command` field builder.
    pub fn property_command(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("command")
            .expect("BashToolArgs.command is statically defined in .baml and should always be present")
    }


    /// Access the `cmd` field builder.
    pub fn property_cmd(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("cmd")
            .expect("BashToolArgs.cmd is statically defined in .baml and should always be present")
    }


    /// Access the `cwd` field builder.
    pub fn property_cwd(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("cwd")
            .expect("BashToolArgs.cwd is statically defined in .baml and should always be present")
    }


    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning")
            .expect("BashToolArgs.reasoning is statically defined in .baml and should always be present")
    }


    /// Access the `timeout_ms` field builder.
    pub fn property_timeout_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timeout_ms")
            .expect("BashToolArgs.timeout_ms is statically defined in .baml and should always be present")
    }


    /// Access the `model` field builder.
    pub fn property_model(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("model")
            .expect("BashToolArgs.model is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `CompletionPayload` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct CompletionPayloadClassBuilder {
    inner: baml::ClassBuilder,
}

impl CompletionPayloadClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("CompletionPayload is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `objective_status` field builder.
    pub fn property_objective_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective_status")
            .expect("CompletionPayload.objective_status is statically defined in .baml and should always be present")
    }


    /// Access the `objective_fulfilled` field builder.
    pub fn property_objective_fulfilled(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective_fulfilled")
            .expect("CompletionPayload.objective_fulfilled is statically defined in .baml and should always be present")
    }


    /// Access the `completion_reason` field builder.
    pub fn property_completion_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("completion_reason")
            .expect("CompletionPayload.completion_reason is statically defined in .baml and should always be present")
    }


    /// Access the `evidence` field builder.
    pub fn property_evidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("evidence")
            .expect("CompletionPayload.evidence is statically defined in .baml and should always be present")
    }


    /// Access the `unresolved_items` field builder.
    pub fn property_unresolved_items(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("unresolved_items")
            .expect("CompletionPayload.unresolved_items is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_next_action` field builder.
    pub fn property_recommended_next_action(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_next_action")
            .expect("CompletionPayload.recommended_next_action is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorAgendaItem` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorAgendaItemClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorAgendaItemClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorAgendaItem is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `id` field builder.
    pub fn property_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("id")
            .expect("ConductorAgendaItem.id is statically defined in .baml and should always be present")
    }


    /// Access the `capability` field builder.
    pub fn property_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("capability")
            .expect("ConductorAgendaItem.capability is statically defined in .baml and should always be present")
    }


    /// Access the `objective` field builder.
    pub fn property_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective")
            .expect("ConductorAgendaItem.objective is statically defined in .baml and should always be present")
    }


    /// Access the `dependencies` field builder.
    pub fn property_dependencies(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("dependencies")
            .expect("ConductorAgendaItem.dependencies is statically defined in .baml and should always be present")
    }


    /// Access the `status` field builder.
    pub fn property_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("status")
            .expect("ConductorAgendaItem.status is statically defined in .baml and should always be present")
    }


    /// Access the `priority` field builder.
    pub fn property_priority(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("priority")
            .expect("ConductorAgendaItem.priority is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorArtifact` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorArtifactClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorArtifactClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorArtifact is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `artifact_id` field builder.
    pub fn property_artifact_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("artifact_id")
            .expect("ConductorArtifact.artifact_id is statically defined in .baml and should always be present")
    }


    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("name")
            .expect("ConductorArtifact.name is statically defined in .baml and should always be present")
    }


    /// Access the `content_type` field builder.
    pub fn property_content_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content_type")
            .expect("ConductorArtifact.content_type is statically defined in .baml and should always be present")
    }


    /// Access the `summary` field builder.
    pub fn property_summary(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("summary")
            .expect("ConductorArtifact.summary is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorBootstrapInput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorBootstrapInputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorBootstrapInputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorBootstrapInput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `raw_objective` field builder.
    pub fn property_raw_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("raw_objective")
            .expect("ConductorBootstrapInput.raw_objective is statically defined in .baml and should always be present")
    }


    /// Access the `available_capabilities` field builder.
    pub fn property_available_capabilities(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("available_capabilities")
            .expect("ConductorBootstrapInput.available_capabilities is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorBootstrapOutput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorBootstrapOutputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorBootstrapOutputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorBootstrapOutput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `dispatch_capabilities` field builder.
    pub fn property_dispatch_capabilities(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("dispatch_capabilities")
            .expect("ConductorBootstrapOutput.dispatch_capabilities is statically defined in .baml and should always be present")
    }


    /// Access the `block_reason` field builder.
    pub fn property_block_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("block_reason")
            .expect("ConductorBootstrapOutput.block_reason is statically defined in .baml and should always be present")
    }


    /// Access the `rationale` field builder.
    pub fn property_rationale(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("rationale")
            .expect("ConductorBootstrapOutput.rationale is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("ConductorBootstrapOutput.confidence is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorCapabilityCall` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorCapabilityCallClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorCapabilityCallClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorCapabilityCall is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `call_id` field builder.
    pub fn property_call_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("call_id")
            .expect("ConductorCapabilityCall.call_id is statically defined in .baml and should always be present")
    }


    /// Access the `agenda_item_id` field builder.
    pub fn property_agenda_item_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("agenda_item_id")
            .expect("ConductorCapabilityCall.agenda_item_id is statically defined in .baml and should always be present")
    }


    /// Access the `capability` field builder.
    pub fn property_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("capability")
            .expect("ConductorCapabilityCall.capability is statically defined in .baml and should always be present")
    }


    /// Access the `objective` field builder.
    pub fn property_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective")
            .expect("ConductorCapabilityCall.objective is statically defined in .baml and should always be present")
    }


    /// Access the `status` field builder.
    pub fn property_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("status")
            .expect("ConductorCapabilityCall.status is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorDecisionInput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorDecisionInputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorDecisionInputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorDecisionInput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `run_id` field builder.
    pub fn property_run_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("run_id")
            .expect("ConductorDecisionInput.run_id is statically defined in .baml and should always be present")
    }


    /// Access the `task_id` field builder.
    pub fn property_task_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("task_id")
            .expect("ConductorDecisionInput.task_id is statically defined in .baml and should always be present")
    }


    /// Access the `objective` field builder.
    pub fn property_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective")
            .expect("ConductorDecisionInput.objective is statically defined in .baml and should always be present")
    }


    /// Access the `run_status` field builder.
    pub fn property_run_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("run_status")
            .expect("ConductorDecisionInput.run_status is statically defined in .baml and should always be present")
    }


    /// Access the `agenda` field builder.
    pub fn property_agenda(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("agenda")
            .expect("ConductorDecisionInput.agenda is statically defined in .baml and should always be present")
    }


    /// Access the `active_calls` field builder.
    pub fn property_active_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("active_calls")
            .expect("ConductorDecisionInput.active_calls is statically defined in .baml and should always be present")
    }


    /// Access the `artifacts` field builder.
    pub fn property_artifacts(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("artifacts")
            .expect("ConductorDecisionInput.artifacts is statically defined in .baml and should always be present")
    }


    /// Access the `recent_events` field builder.
    pub fn property_recent_events(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recent_events")
            .expect("ConductorDecisionInput.recent_events is statically defined in .baml and should always be present")
    }


    /// Access the `worker_outputs` field builder.
    pub fn property_worker_outputs(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("worker_outputs")
            .expect("ConductorDecisionInput.worker_outputs is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorDecisionOutput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorDecisionOutputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorDecisionOutputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorDecisionOutput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `decision_type` field builder.
    pub fn property_decision_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("decision_type")
            .expect("ConductorDecisionOutput.decision_type is statically defined in .baml and should always be present")
    }


    /// Access the `target_agenda_item_ids` field builder.
    pub fn property_target_agenda_item_ids(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("target_agenda_item_ids")
            .expect("ConductorDecisionOutput.target_agenda_item_ids is statically defined in .baml and should always be present")
    }


    /// Access the `new_agenda_items` field builder.
    pub fn property_new_agenda_items(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("new_agenda_items")
            .expect("ConductorDecisionOutput.new_agenda_items is statically defined in .baml and should always be present")
    }


    /// Access the `capability` field builder.
    pub fn property_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("capability")
            .expect("ConductorDecisionOutput.capability is statically defined in .baml and should always be present")
    }


    /// Access the `objective` field builder.
    pub fn property_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective")
            .expect("ConductorDecisionOutput.objective is statically defined in .baml and should always be present")
    }


    /// Access the `retry_policy` field builder.
    pub fn property_retry_policy(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("retry_policy")
            .expect("ConductorDecisionOutput.retry_policy is statically defined in .baml and should always be present")
    }


    /// Access the `completion_reason` field builder.
    pub fn property_completion_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("completion_reason")
            .expect("ConductorDecisionOutput.completion_reason is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("ConductorDecisionOutput.confidence is statically defined in .baml and should always be present")
    }


    /// Access the `rationale` field builder.
    pub fn property_rationale(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("rationale")
            .expect("ConductorDecisionOutput.rationale is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorObjectiveRefineInput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorObjectiveRefineInputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorObjectiveRefineInputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorObjectiveRefineInput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `raw_objective` field builder.
    pub fn property_raw_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("raw_objective")
            .expect("ConductorObjectiveRefineInput.raw_objective is statically defined in .baml and should always be present")
    }


    /// Access the `context` field builder.
    pub fn property_context(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("context")
            .expect("ConductorObjectiveRefineInput.context is statically defined in .baml and should always be present")
    }


    /// Access the `target_capability` field builder.
    pub fn property_target_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("target_capability")
            .expect("ConductorObjectiveRefineInput.target_capability is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorObjectiveRefineOutput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorObjectiveRefineOutputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorObjectiveRefineOutputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorObjectiveRefineOutput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `refined_objective` field builder.
    pub fn property_refined_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("refined_objective")
            .expect("ConductorObjectiveRefineOutput.refined_objective is statically defined in .baml and should always be present")
    }


    /// Access the `success_criteria` field builder.
    pub fn property_success_criteria(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("success_criteria")
            .expect("ConductorObjectiveRefineOutput.success_criteria is statically defined in .baml and should always be present")
    }


    /// Access the `estimated_steps` field builder.
    pub fn property_estimated_steps(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("estimated_steps")
            .expect("ConductorObjectiveRefineOutput.estimated_steps is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("ConductorObjectiveRefineOutput.confidence is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorTerminalityInput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorTerminalityInputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorTerminalityInputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorTerminalityInput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `run_id` field builder.
    pub fn property_run_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("run_id")
            .expect("ConductorTerminalityInput.run_id is statically defined in .baml and should always be present")
    }


    /// Access the `agenda` field builder.
    pub fn property_agenda(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("agenda")
            .expect("ConductorTerminalityInput.agenda is statically defined in .baml and should always be present")
    }


    /// Access the `artifacts` field builder.
    pub fn property_artifacts(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("artifacts")
            .expect("ConductorTerminalityInput.artifacts is statically defined in .baml and should always be present")
    }


    /// Access the `original_objective` field builder.
    pub fn property_original_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("original_objective")
            .expect("ConductorTerminalityInput.original_objective is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ConductorTerminalityOutput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ConductorTerminalityOutputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ConductorTerminalityOutputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ConductorTerminalityOutput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `terminality_status` field builder.
    pub fn property_terminality_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("terminality_status")
            .expect("ConductorTerminalityOutput.terminality_status is statically defined in .baml and should always be present")
    }


    /// Access the `reason` field builder.
    pub fn property_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reason")
            .expect("ConductorTerminalityOutput.reason is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("ConductorTerminalityOutput.confidence is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `DetectedAnomaly` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct DetectedAnomalyClassBuilder {
    inner: baml::ClassBuilder,
}

impl DetectedAnomalyClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("DetectedAnomaly is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `anomaly_type` field builder.
    pub fn property_anomaly_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("anomaly_type")
            .expect("DetectedAnomaly.anomaly_type is statically defined in .baml and should always be present")
    }


    /// Access the `severity` field builder.
    pub fn property_severity(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("severity")
            .expect("DetectedAnomaly.severity is statically defined in .baml and should always be present")
    }


    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description")
            .expect("DetectedAnomaly.description is statically defined in .baml and should always be present")
    }


    /// Access the `affected_events` field builder.
    pub fn property_affected_events(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("affected_events")
            .expect("DetectedAnomaly.affected_events is statically defined in .baml and should always be present")
    }


    /// Access the `pattern_detected` field builder.
    pub fn property_pattern_detected(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pattern_detected")
            .expect("DetectedAnomaly.pattern_detected is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `EventSummary` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct EventSummaryClassBuilder {
    inner: baml::ClassBuilder,
}

impl EventSummaryClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("EventSummary is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `event_id` field builder.
    pub fn property_event_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("event_id")
            .expect("EventSummary.event_id is statically defined in .baml and should always be present")
    }


    /// Access the `event_type` field builder.
    pub fn property_event_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("event_type")
            .expect("EventSummary.event_type is statically defined in .baml and should always be present")
    }


    /// Access the `timestamp` field builder.
    pub fn property_timestamp(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timestamp")
            .expect("EventSummary.timestamp is statically defined in .baml and should always be present")
    }


    /// Access the `payload` field builder.
    pub fn property_payload(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("payload")
            .expect("EventSummary.payload is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `Evidence` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct EvidenceClassBuilder {
    inner: baml::ClassBuilder,
}

impl EvidenceClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("Evidence is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `evidence_id` field builder.
    pub fn property_evidence_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("evidence_id")
            .expect("Evidence.evidence_id is statically defined in .baml and should always be present")
    }


    /// Access the `evidence_type` field builder.
    pub fn property_evidence_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("evidence_type")
            .expect("Evidence.evidence_type is statically defined in .baml and should always be present")
    }


    /// Access the `source` field builder.
    pub fn property_source(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("source")
            .expect("Evidence.source is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("Evidence.content is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("Evidence.confidence is statically defined in .baml and should always be present")
    }


    /// Access the `timestamp` field builder.
    pub fn property_timestamp(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timestamp")
            .expect("Evidence.timestamp is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `FollowupRecommendation` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct FollowupRecommendationClassBuilder {
    inner: baml::ClassBuilder,
}

impl FollowupRecommendationClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("FollowupRecommendation is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `capability` field builder.
    pub fn property_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("capability")
            .expect("FollowupRecommendation.capability is statically defined in .baml and should always be present")
    }


    /// Access the `objective` field builder.
    pub fn property_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective")
            .expect("FollowupRecommendation.objective is statically defined in .baml and should always be present")
    }


    /// Access the `priority` field builder.
    pub fn property_priority(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("priority")
            .expect("FollowupRecommendation.priority is statically defined in .baml and should always be present")
    }


    /// Access the `rationale` field builder.
    pub fn property_rationale(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("rationale")
            .expect("FollowupRecommendation.rationale is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `HistoricalResolution` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct HistoricalResolutionClassBuilder {
    inner: baml::ClassBuilder,
}

impl HistoricalResolutionClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("HistoricalResolution is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `pattern` field builder.
    pub fn property_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pattern")
            .expect("HistoricalResolution.pattern is statically defined in .baml and should always be present")
    }


    /// Access the `successful_resolution` field builder.
    pub fn property_successful_resolution(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("successful_resolution")
            .expect("HistoricalResolution.successful_resolution is statically defined in .baml and should always be present")
    }


    /// Access the `resolution_type` field builder.
    pub fn property_resolution_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("resolution_type")
            .expect("HistoricalResolution.resolution_type is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ListFilesToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ListFilesToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl ListFilesToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ListFilesToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path")
            .expect("ListFilesToolArgs.path is statically defined in .baml and should always be present")
    }


    /// Access the `recursive` field builder.
    pub fn property_recursive(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recursive")
            .expect("ListFilesToolArgs.recursive is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `Message` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct MessageClassBuilder {
    inner: baml::ClassBuilder,
}

impl MessageClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("Message is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `role` field builder.
    pub fn property_role(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("role")
            .expect("Message.role is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("Message.content is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `NextAction` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct NextActionClassBuilder {
    inner: baml::ClassBuilder,
}

impl NextActionClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("NextAction is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `action_type` field builder.
    pub fn property_action_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("action_type")
            .expect("NextAction.action_type is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_capability` field builder.
    pub fn property_recommended_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_capability")
            .expect("NextAction.recommended_capability is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_objective` field builder.
    pub fn property_recommended_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_objective")
            .expect("NextAction.recommended_objective is statically defined in .baml and should always be present")
    }


    /// Access the `rationale` field builder.
    pub fn property_rationale(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("rationale")
            .expect("NextAction.rationale is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ObjectiveContract` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ObjectiveContractClassBuilder {
    inner: baml::ClassBuilder,
}

impl ObjectiveContractClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ObjectiveContract is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `objective_id` field builder.
    pub fn property_objective_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective_id")
            .expect("ObjectiveContract.objective_id is statically defined in .baml and should always be present")
    }


    /// Access the `parent_objective_id` field builder.
    pub fn property_parent_objective_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("parent_objective_id")
            .expect("ObjectiveContract.parent_objective_id is statically defined in .baml and should always be present")
    }


    /// Access the `primary_objective` field builder.
    pub fn property_primary_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("primary_objective")
            .expect("ObjectiveContract.primary_objective is statically defined in .baml and should always be present")
    }


    /// Access the `success_criteria` field builder.
    pub fn property_success_criteria(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("success_criteria")
            .expect("ObjectiveContract.success_criteria is statically defined in .baml and should always be present")
    }


    /// Access the `max_tool_calls` field builder.
    pub fn property_max_tool_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("max_tool_calls")
            .expect("ObjectiveContract.max_tool_calls is statically defined in .baml and should always be present")
    }


    /// Access the `timeout_ms` field builder.
    pub fn property_timeout_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timeout_ms")
            .expect("ObjectiveContract.timeout_ms is statically defined in .baml and should always be present")
    }


    /// Access the `attempts_budget` field builder.
    pub fn property_attempts_budget(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("attempts_budget")
            .expect("ObjectiveContract.attempts_budget is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ReadFileToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ReadFileToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl ReadFileToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ReadFileToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path")
            .expect("ReadFileToolArgs.path is statically defined in .baml and should always be present")
    }


    /// Access the `limit` field builder.
    pub fn property_limit(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("limit")
            .expect("ReadFileToolArgs.limit is statically defined in .baml and should always be present")
    }


    /// Access the `offset` field builder.
    pub fn property_offset(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("offset")
            .expect("ReadFileToolArgs.offset is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ResearcherCitationInput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResearcherCitationInputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResearcherCitationInputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ResearcherCitationInput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `provider` field builder.
    pub fn property_provider(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider")
            .expect("ResearcherCitationInput.provider is statically defined in .baml and should always be present")
    }


    /// Access the `title` field builder.
    pub fn property_title(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("title")
            .expect("ResearcherCitationInput.title is statically defined in .baml and should always be present")
    }


    /// Access the `url` field builder.
    pub fn property_url(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("url")
            .expect("ResearcherCitationInput.url is statically defined in .baml and should always be present")
    }


    /// Access the `snippet` field builder.
    pub fn property_snippet(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("snippet")
            .expect("ResearcherCitationInput.snippet is statically defined in .baml and should always be present")
    }


    /// Access the `published_at` field builder.
    pub fn property_published_at(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("published_at")
            .expect("ResearcherCitationInput.published_at is statically defined in .baml and should always be present")
    }


    /// Access the `score` field builder.
    pub fn property_score(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("score")
            .expect("ResearcherCitationInput.score is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ResearcherFetchedPageInput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResearcherFetchedPageInputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResearcherFetchedPageInputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ResearcherFetchedPageInput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `url` field builder.
    pub fn property_url(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("url")
            .expect("ResearcherFetchedPageInput.url is statically defined in .baml and should always be present")
    }


    /// Access the `status_code` field builder.
    pub fn property_status_code(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("status_code")
            .expect("ResearcherFetchedPageInput.status_code is statically defined in .baml and should always be present")
    }


    /// Access the `content_excerpt` field builder.
    pub fn property_content_excerpt(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content_excerpt")
            .expect("ResearcherFetchedPageInput.content_excerpt is statically defined in .baml and should always be present")
    }


    /// Access the `success` field builder.
    pub fn property_success(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("success")
            .expect("ResearcherFetchedPageInput.success is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ResearcherPlanInput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResearcherPlanInputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResearcherPlanInputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ResearcherPlanInput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `objective` field builder.
    pub fn property_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective")
            .expect("ResearcherPlanInput.objective is statically defined in .baml and should always be present")
    }


    /// Access the `current_query` field builder.
    pub fn property_current_query(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("current_query")
            .expect("ResearcherPlanInput.current_query is statically defined in .baml and should always be present")
    }


    /// Access the `round` field builder.
    pub fn property_round(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("round")
            .expect("ResearcherPlanInput.round is statically defined in .baml and should always be present")
    }


    /// Access the `max_rounds` field builder.
    pub fn property_max_rounds(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("max_rounds")
            .expect("ResearcherPlanInput.max_rounds is statically defined in .baml and should always be present")
    }


    /// Access the `provider_hint` field builder.
    pub fn property_provider_hint(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider_hint")
            .expect("ResearcherPlanInput.provider_hint is statically defined in .baml and should always be present")
    }


    /// Access the `max_results_hint` field builder.
    pub fn property_max_results_hint(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("max_results_hint")
            .expect("ResearcherPlanInput.max_results_hint is statically defined in .baml and should always be present")
    }


    /// Access the `last_error` field builder.
    pub fn property_last_error(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("last_error")
            .expect("ResearcherPlanInput.last_error is statically defined in .baml and should always be present")
    }


    /// Access the `provider_calls` field builder.
    pub fn property_provider_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider_calls")
            .expect("ResearcherPlanInput.provider_calls is statically defined in .baml and should always be present")
    }


    /// Access the `citations` field builder.
    pub fn property_citations(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("citations")
            .expect("ResearcherPlanInput.citations is statically defined in .baml and should always be present")
    }


    /// Access the `fetched_pages` field builder.
    pub fn property_fetched_pages(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("fetched_pages")
            .expect("ResearcherPlanInput.fetched_pages is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ResearcherPlanOutput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResearcherPlanOutputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResearcherPlanOutputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ResearcherPlanOutput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `action` field builder.
    pub fn property_action(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("action")
            .expect("ResearcherPlanOutput.action is statically defined in .baml and should always be present")
    }


    /// Access the `query` field builder.
    pub fn property_query(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("query")
            .expect("ResearcherPlanOutput.query is statically defined in .baml and should always be present")
    }


    /// Access the `provider` field builder.
    pub fn property_provider(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider")
            .expect("ResearcherPlanOutput.provider is statically defined in .baml and should always be present")
    }


    /// Access the `fetch_url` field builder.
    pub fn property_fetch_url(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("fetch_url")
            .expect("ResearcherPlanOutput.fetch_url is statically defined in .baml and should always be present")
    }


    /// Access the `max_results` field builder.
    pub fn property_max_results(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("max_results")
            .expect("ResearcherPlanOutput.max_results is statically defined in .baml and should always be present")
    }


    /// Access the `time_range` field builder.
    pub fn property_time_range(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("time_range")
            .expect("ResearcherPlanOutput.time_range is statically defined in .baml and should always be present")
    }


    /// Access the `rationale` field builder.
    pub fn property_rationale(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("rationale")
            .expect("ResearcherPlanOutput.rationale is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("ResearcherPlanOutput.confidence is statically defined in .baml and should always be present")
    }


    /// Access the `completion_reason` field builder.
    pub fn property_completion_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("completion_reason")
            .expect("ResearcherPlanOutput.completion_reason is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_next_capability` field builder.
    pub fn property_recommended_next_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_next_capability")
            .expect("ResearcherPlanOutput.recommended_next_capability is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_next_objective` field builder.
    pub fn property_recommended_next_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_next_objective")
            .expect("ResearcherPlanOutput.recommended_next_objective is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ResearcherProviderCallSummary` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResearcherProviderCallSummaryClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResearcherProviderCallSummaryClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ResearcherProviderCallSummary is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `provider` field builder.
    pub fn property_provider(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider")
            .expect("ResearcherProviderCallSummary.provider is statically defined in .baml and should always be present")
    }


    /// Access the `latency_ms` field builder.
    pub fn property_latency_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("latency_ms")
            .expect("ResearcherProviderCallSummary.latency_ms is statically defined in .baml and should always be present")
    }


    /// Access the `result_count` field builder.
    pub fn property_result_count(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("result_count")
            .expect("ResearcherProviderCallSummary.result_count is statically defined in .baml and should always be present")
    }


    /// Access the `succeeded` field builder.
    pub fn property_succeeded(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("succeeded")
            .expect("ResearcherProviderCallSummary.succeeded is statically defined in .baml and should always be present")
    }


    /// Access the `error` field builder.
    pub fn property_error(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("error")
            .expect("ResearcherProviderCallSummary.error is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ResearcherSynthesisInput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResearcherSynthesisInputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResearcherSynthesisInputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ResearcherSynthesisInput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `objective` field builder.
    pub fn property_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective")
            .expect("ResearcherSynthesisInput.objective is statically defined in .baml and should always be present")
    }


    /// Access the `query` field builder.
    pub fn property_query(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("query")
            .expect("ResearcherSynthesisInput.query is statically defined in .baml and should always be present")
    }


    /// Access the `provider_label` field builder.
    pub fn property_provider_label(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider_label")
            .expect("ResearcherSynthesisInput.provider_label is statically defined in .baml and should always be present")
    }


    /// Access the `citations` field builder.
    pub fn property_citations(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("citations")
            .expect("ResearcherSynthesisInput.citations is statically defined in .baml and should always be present")
    }


    /// Access the `provider_calls` field builder.
    pub fn property_provider_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider_calls")
            .expect("ResearcherSynthesisInput.provider_calls is statically defined in .baml and should always be present")
    }


    /// Access the `fetched_pages` field builder.
    pub fn property_fetched_pages(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("fetched_pages")
            .expect("ResearcherSynthesisInput.fetched_pages is statically defined in .baml and should always be present")
    }


    /// Access the `raw_results_count` field builder.
    pub fn property_raw_results_count(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("raw_results_count")
            .expect("ResearcherSynthesisInput.raw_results_count is statically defined in .baml and should always be present")
    }


    /// Access the `errors` field builder.
    pub fn property_errors(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("errors")
            .expect("ResearcherSynthesisInput.errors is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ResearcherSynthesisOutput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResearcherSynthesisOutputClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResearcherSynthesisOutputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ResearcherSynthesisOutput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `summary` field builder.
    pub fn property_summary(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("summary")
            .expect("ResearcherSynthesisOutput.summary is statically defined in .baml and should always be present")
    }


    /// Access the `objective_status` field builder.
    pub fn property_objective_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective_status")
            .expect("ResearcherSynthesisOutput.objective_status is statically defined in .baml and should always be present")
    }


    /// Access the `completion_reason` field builder.
    pub fn property_completion_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("completion_reason")
            .expect("ResearcherSynthesisOutput.completion_reason is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_next_capability` field builder.
    pub fn property_recommended_next_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_next_capability")
            .expect("ResearcherSynthesisOutput.recommended_next_capability is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_next_objective` field builder.
    pub fn property_recommended_next_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_next_objective")
            .expect("ResearcherSynthesisOutput.recommended_next_objective is statically defined in .baml and should always be present")
    }


    /// Access the `key_findings` field builder.
    pub fn property_key_findings(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("key_findings")
            .expect("ResearcherSynthesisOutput.key_findings is statically defined in .baml and should always be present")
    }


    /// Access the `gaps` field builder.
    pub fn property_gaps(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("gaps")
            .expect("ResearcherSynthesisOutput.gaps is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("ResearcherSynthesisOutput.confidence is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `Resume` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResumeClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResumeClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("Resume is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("name")
            .expect("Resume.name is statically defined in .baml and should always be present")
    }


    /// Access the `email` field builder.
    pub fn property_email(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("email")
            .expect("Resume.email is statically defined in .baml and should always be present")
    }


    /// Access the `experience` field builder.
    pub fn property_experience(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("experience")
            .expect("Resume.experience is statically defined in .baml and should always be present")
    }


    /// Access the `skills` field builder.
    pub fn property_skills(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("skills")
            .expect("Resume.skills is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `RetryPolicy` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct RetryPolicyClassBuilder {
    inner: baml::ClassBuilder,
}

impl RetryPolicyClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("RetryPolicy is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `max_attempts` field builder.
    pub fn property_max_attempts(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("max_attempts")
            .expect("RetryPolicy.max_attempts is statically defined in .baml and should always be present")
    }


    /// Access the `backoff_strategy` field builder.
    pub fn property_backoff_strategy(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("backoff_strategy")
            .expect("RetryPolicy.backoff_strategy is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ReviewScope` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ReviewScopeClassBuilder {
    inner: baml::ClassBuilder,
}

impl ReviewScopeClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ReviewScope is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `start_time` field builder.
    pub fn property_start_time(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("start_time")
            .expect("ReviewScope.start_time is statically defined in .baml and should always be present")
    }


    /// Access the `end_time` field builder.
    pub fn property_end_time(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("end_time")
            .expect("ReviewScope.end_time is statically defined in .baml and should always be present")
    }


    /// Access the `event_types` field builder.
    pub fn property_event_types(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("event_types")
            .expect("ReviewScope.event_types is statically defined in .baml and should always be present")
    }


    /// Access the `min_level` field builder.
    pub fn property_min_level(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("min_level")
            .expect("ReviewScope.min_level is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `RiskItem` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct RiskItemClassBuilder {
    inner: baml::ClassBuilder,
}

impl RiskItemClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("RiskItem is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `risk_id` field builder.
    pub fn property_risk_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("risk_id")
            .expect("RiskItem.risk_id is statically defined in .baml and should always be present")
    }


    /// Access the `category` field builder.
    pub fn property_category(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("category")
            .expect("RiskItem.category is statically defined in .baml and should always be present")
    }


    /// Access the `likelihood` field builder.
    pub fn property_likelihood(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("likelihood")
            .expect("RiskItem.likelihood is statically defined in .baml and should always be present")
    }


    /// Access the `impact` field builder.
    pub fn property_impact(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("impact")
            .expect("RiskItem.impact is statically defined in .baml and should always be present")
    }


    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description")
            .expect("RiskItem.description is statically defined in .baml and should always be present")
    }


    /// Access the `mitigating_factors` field builder.
    pub fn property_mitigating_factors(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("mitigating_factors")
            .expect("RiskItem.mitigating_factors is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `RunStateSnapshot` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct RunStateSnapshotClassBuilder {
    inner: baml::ClassBuilder,
}

impl RunStateSnapshotClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("RunStateSnapshot is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `run_id` field builder.
    pub fn property_run_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("run_id")
            .expect("RunStateSnapshot.run_id is statically defined in .baml and should always be present")
    }


    /// Access the `status` field builder.
    pub fn property_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("status")
            .expect("RunStateSnapshot.status is statically defined in .baml and should always be present")
    }


    /// Access the `active_call_count` field builder.
    pub fn property_active_call_count(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("active_call_count")
            .expect("RunStateSnapshot.active_call_count is statically defined in .baml and should always be present")
    }


    /// Access the `recent_failures` field builder.
    pub fn property_recent_failures(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recent_failures")
            .expect("RunStateSnapshot.recent_failures is statically defined in .baml and should always be present")
    }


    /// Access the `elapsed_time_ms` field builder.
    pub fn property_elapsed_time_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("elapsed_time_ms")
            .expect("RunStateSnapshot.elapsed_time_ms is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `SearchFilesToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct SearchFilesToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl SearchFilesToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("SearchFilesToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `pattern` field builder.
    pub fn property_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pattern")
            .expect("SearchFilesToolArgs.pattern is statically defined in .baml and should always be present")
    }


    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path")
            .expect("SearchFilesToolArgs.path is statically defined in .baml and should always be present")
    }


    /// Access the `file_pattern` field builder.
    pub fn property_file_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("file_pattern")
            .expect("SearchFilesToolArgs.file_pattern is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `StreamChunk` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct StreamChunkClassBuilder {
    inner: baml::ClassBuilder,
}

impl StreamChunkClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("StreamChunk is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `chunk_type` field builder.
    pub fn property_chunk_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("chunk_type")
            .expect("StreamChunk.chunk_type is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("StreamChunk.content is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `ToolResult` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ToolResultClassBuilder {
    inner: baml::ClassBuilder,
}

impl ToolResultClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("ToolResult is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `tool_name` field builder.
    pub fn property_tool_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_name")
            .expect("ToolResult.tool_name is statically defined in .baml and should always be present")
    }


    /// Access the `success` field builder.
    pub fn property_success(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("success")
            .expect("ToolResult.success is statically defined in .baml and should always be present")
    }


    /// Access the `output` field builder.
    pub fn property_output(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("output")
            .expect("ToolResult.output is statically defined in .baml and should always be present")
    }


    /// Access the `error` field builder.
    pub fn property_error(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("error")
            .expect("ToolResult.error is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `UnresolvedItem` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct UnresolvedItemClassBuilder {
    inner: baml::ClassBuilder,
}

impl UnresolvedItemClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("UnresolvedItem is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `item_id` field builder.
    pub fn property_item_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("item_id")
            .expect("UnresolvedItem.item_id is statically defined in .baml and should always be present")
    }


    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description")
            .expect("UnresolvedItem.description is statically defined in .baml and should always be present")
    }


    /// Access the `reason` field builder.
    pub fn property_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reason")
            .expect("UnresolvedItem.reason is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `WatcherEscalation` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WatcherEscalationClassBuilder {
    inner: baml::ClassBuilder,
}

impl WatcherEscalationClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("WatcherEscalation is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `escalation_id` field builder.
    pub fn property_escalation_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("escalation_id")
            .expect("WatcherEscalation.escalation_id is statically defined in .baml and should always be present")
    }


    /// Access the `run_id` field builder.
    pub fn property_run_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("run_id")
            .expect("WatcherEscalation.run_id is statically defined in .baml and should always be present")
    }


    /// Access the `task_id` field builder.
    pub fn property_task_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("task_id")
            .expect("WatcherEscalation.task_id is statically defined in .baml and should always be present")
    }


    /// Access the `kind` field builder.
    pub fn property_kind(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("kind")
            .expect("WatcherEscalation.kind is statically defined in .baml and should always be present")
    }


    /// Access the `urgency` field builder.
    pub fn property_urgency(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("urgency")
            .expect("WatcherEscalation.urgency is statically defined in .baml and should always be present")
    }


    /// Access the `affected_calls` field builder.
    pub fn property_affected_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("affected_calls")
            .expect("WatcherEscalation.affected_calls is statically defined in .baml and should always be present")
    }


    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description")
            .expect("WatcherEscalation.description is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_action` field builder.
    pub fn property_recommended_action(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_action")
            .expect("WatcherEscalation.recommended_action is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_capability` field builder.
    pub fn property_recommended_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_capability")
            .expect("WatcherEscalation.recommended_capability is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_objective` field builder.
    pub fn property_recommended_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_objective")
            .expect("WatcherEscalation.recommended_objective is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `WatcherEvent` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WatcherEventClassBuilder {
    inner: baml::ClassBuilder,
}

impl WatcherEventClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("WatcherEvent is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `event_id` field builder.
    pub fn property_event_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("event_id")
            .expect("WatcherEvent.event_id is statically defined in .baml and should always be present")
    }


    /// Access the `timestamp` field builder.
    pub fn property_timestamp(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timestamp")
            .expect("WatcherEvent.timestamp is statically defined in .baml and should always be present")
    }


    /// Access the `event_type` field builder.
    pub fn property_event_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("event_type")
            .expect("WatcherEvent.event_type is statically defined in .baml and should always be present")
    }


    /// Access the `level` field builder.
    pub fn property_level(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("level")
            .expect("WatcherEvent.level is statically defined in .baml and should always be present")
    }


    /// Access the `payload` field builder.
    pub fn property_payload(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("payload")
            .expect("WatcherEvent.payload is statically defined in .baml and should always be present")
    }


    /// Access the `source` field builder.
    pub fn property_source(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("source")
            .expect("WatcherEvent.source is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `WatcherLogWindowInput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WatcherLogWindowInputClassBuilder {
    inner: baml::ClassBuilder,
}

impl WatcherLogWindowInputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("WatcherLogWindowInput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `window_id` field builder.
    pub fn property_window_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("window_id")
            .expect("WatcherLogWindowInput.window_id is statically defined in .baml and should always be present")
    }


    /// Access the `run_id` field builder.
    pub fn property_run_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("run_id")
            .expect("WatcherLogWindowInput.run_id is statically defined in .baml and should always be present")
    }


    /// Access the `task_id` field builder.
    pub fn property_task_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("task_id")
            .expect("WatcherLogWindowInput.task_id is statically defined in .baml and should always be present")
    }


    /// Access the `events` field builder.
    pub fn property_events(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("events")
            .expect("WatcherLogWindowInput.events is statically defined in .baml and should always be present")
    }


    /// Access the `scope` field builder.
    pub fn property_scope(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("scope")
            .expect("WatcherLogWindowInput.scope is statically defined in .baml and should always be present")
    }


    /// Access the `review_reason` field builder.
    pub fn property_review_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("review_reason")
            .expect("WatcherLogWindowInput.review_reason is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `WatcherMitigationInput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WatcherMitigationInputClassBuilder {
    inner: baml::ClassBuilder,
}

impl WatcherMitigationInputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("WatcherMitigationInput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `escalation` field builder.
    pub fn property_escalation(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("escalation")
            .expect("WatcherMitigationInput.escalation is statically defined in .baml and should always be present")
    }


    /// Access the `run_state` field builder.
    pub fn property_run_state(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("run_state")
            .expect("WatcherMitigationInput.run_state is statically defined in .baml and should always be present")
    }


    /// Access the `available_capabilities` field builder.
    pub fn property_available_capabilities(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("available_capabilities")
            .expect("WatcherMitigationInput.available_capabilities is statically defined in .baml and should always be present")
    }


    /// Access the `historical_resolutions` field builder.
    pub fn property_historical_resolutions(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("historical_resolutions")
            .expect("WatcherMitigationInput.historical_resolutions is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `WatcherMitigationOutput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WatcherMitigationOutputClassBuilder {
    inner: baml::ClassBuilder,
}

impl WatcherMitigationOutputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("WatcherMitigationOutput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `escalation_action` field builder.
    pub fn property_escalation_action(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("escalation_action")
            .expect("WatcherMitigationOutput.escalation_action is statically defined in .baml and should always be present")
    }


    /// Access the `urgency` field builder.
    pub fn property_urgency(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("urgency")
            .expect("WatcherMitigationOutput.urgency is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_capability` field builder.
    pub fn property_recommended_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_capability")
            .expect("WatcherMitigationOutput.recommended_capability is statically defined in .baml and should always be present")
    }


    /// Access the `recommended_objective` field builder.
    pub fn property_recommended_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_objective")
            .expect("WatcherMitigationOutput.recommended_objective is statically defined in .baml and should always be present")
    }


    /// Access the `rationale` field builder.
    pub fn property_rationale(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("rationale")
            .expect("WatcherMitigationOutput.rationale is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("WatcherMitigationOutput.confidence is statically defined in .baml and should always be present")
    }


    /// Access the `expected_outcome` field builder.
    pub fn property_expected_outcome(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("expected_outcome")
            .expect("WatcherMitigationOutput.expected_outcome is statically defined in .baml and should always be present")
    }


    /// Access the `alternatives` field builder.
    pub fn property_alternatives(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("alternatives")
            .expect("WatcherMitigationOutput.alternatives is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `WatcherReviewOutput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WatcherReviewOutputClassBuilder {
    inner: baml::ClassBuilder,
}

impl WatcherReviewOutputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("WatcherReviewOutput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `review_status` field builder.
    pub fn property_review_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("review_status")
            .expect("WatcherReviewOutput.review_status is statically defined in .baml and should always be present")
    }


    /// Access the `escalations` field builder.
    pub fn property_escalations(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("escalations")
            .expect("WatcherReviewOutput.escalations is statically defined in .baml and should always be present")
    }


    /// Access the `risks` field builder.
    pub fn property_risks(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("risks")
            .expect("WatcherReviewOutput.risks is statically defined in .baml and should always be present")
    }


    /// Access the `anomalies` field builder.
    pub fn property_anomalies(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("anomalies")
            .expect("WatcherReviewOutput.anomalies is statically defined in .baml and should always be present")
    }


    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence")
            .expect("WatcherReviewOutput.confidence is statically defined in .baml and should always be present")
    }


    /// Access the `rationale` field builder.
    pub fn property_rationale(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("rationale")
            .expect("WatcherReviewOutput.rationale is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `WebSearchToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WebSearchToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl WebSearchToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("WebSearchToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `query` field builder.
    pub fn property_query(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("query")
            .expect("WebSearchToolArgs.query is statically defined in .baml and should always be present")
    }


    /// Access the `provider` field builder.
    pub fn property_provider(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider")
            .expect("WebSearchToolArgs.provider is statically defined in .baml and should always be present")
    }


    /// Access the `max_results` field builder.
    pub fn property_max_results(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("max_results")
            .expect("WebSearchToolArgs.max_results is statically defined in .baml and should always be present")
    }


    /// Access the `time_range` field builder.
    pub fn property_time_range(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("time_range")
            .expect("WebSearchToolArgs.time_range is statically defined in .baml and should always be present")
    }


    /// Access the `include_domains` field builder.
    pub fn property_include_domains(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("include_domains")
            .expect("WebSearchToolArgs.include_domains is statically defined in .baml and should always be present")
    }


    /// Access the `exclude_domains` field builder.
    pub fn property_exclude_domains(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("exclude_domains")
            .expect("WebSearchToolArgs.exclude_domains is statically defined in .baml and should always be present")
    }


    /// Access the `timeout_ms` field builder.
    pub fn property_timeout_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timeout_ms")
            .expect("WebSearchToolArgs.timeout_ms is statically defined in .baml and should always be present")
    }


    /// Access the `model` field builder.
    pub fn property_model(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("model")
            .expect("WebSearchToolArgs.model is statically defined in .baml and should always be present")
    }


    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning")
            .expect("WebSearchToolArgs.reasoning is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `WorkerOutput` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WorkerOutputClassBuilder {
    inner: baml::ClassBuilder,
}

impl WorkerOutputClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("WorkerOutput is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `call_id` field builder.
    pub fn property_call_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("call_id")
            .expect("WorkerOutput.call_id is statically defined in .baml and should always be present")
    }


    /// Access the `agenda_item_id` field builder.
    pub fn property_agenda_item_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("agenda_item_id")
            .expect("WorkerOutput.agenda_item_id is statically defined in .baml and should always be present")
    }


    /// Access the `status` field builder.
    pub fn property_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("status")
            .expect("WorkerOutput.status is statically defined in .baml and should always be present")
    }


    /// Access the `result_summary` field builder.
    pub fn property_result_summary(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("result_summary")
            .expect("WorkerOutput.result_summary is statically defined in .baml and should always be present")
    }


    /// Access the `artifacts_produced` field builder.
    pub fn property_artifacts_produced(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("artifacts_produced")
            .expect("WorkerOutput.artifacts_produced is statically defined in .baml and should always be present")
    }


    /// Access the `followup_recommendations` field builder.
    pub fn property_followup_recommendations(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("followup_recommendations")
            .expect("WorkerOutput.followup_recommendations is statically defined in .baml and should always be present")
    }

}


/// Wrapper for the `WriteFileToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WriteFileToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl WriteFileToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type()
            .expect("WriteFileToolArgs is statically defined in .baml and should always have a type")
    }


    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================


    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path")
            .expect("WriteFileToolArgs.path is statically defined in .baml and should always be present")
    }


    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content")
            .expect("WriteFileToolArgs.content is statically defined in .baml and should always be present")
    }

}

