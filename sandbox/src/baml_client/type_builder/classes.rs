// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Generated class builder wrappers for type-safe field access.

/// Wrapper for the `AgentPlan` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentPlanClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentPlanClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("AgentPlan is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `thinking` field builder.
    pub fn property_thinking(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("thinking").expect(
            "AgentPlan.thinking is statically defined in .baml and should always be present",
        )
    }

    /// Access the `tool_calls` field builder.
    pub fn property_tool_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_calls").expect(
            "AgentPlan.tool_calls is statically defined in .baml and should always be present",
        )
    }

    /// Access the `final_response` field builder.
    pub fn property_final_response(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("final_response").expect(
            "AgentPlan.final_response is statically defined in .baml and should always be present",
        )
    }

    /// Access the `objective_status` field builder.
    pub fn property_objective_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective_status")
            .expect("AgentPlan.objective_status is statically defined in .baml and should always be present")
    }

    /// Access the `plan_mode` field builder.
    pub fn property_plan_mode(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("plan_mode").expect(
            "AgentPlan.plan_mode is statically defined in .baml and should always be present",
        )
    }

    /// Access the `completion_reason` field builder.
    pub fn property_completion_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("completion_reason")
            .expect("AgentPlan.completion_reason is statically defined in .baml and should always be present")
    }

    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence").expect(
            "AgentPlan.confidence is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `AgentToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("AgentToolArgs is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `bash` field builder.
    pub fn property_bash(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("bash").expect(
            "AgentToolArgs.bash is statically defined in .baml and should always be present",
        )
    }

    /// Access the `read_file` field builder.
    pub fn property_read_file(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("read_file").expect(
            "AgentToolArgs.read_file is statically defined in .baml and should always be present",
        )
    }

    /// Access the `write_file` field builder.
    pub fn property_write_file(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("write_file").expect(
            "AgentToolArgs.write_file is statically defined in .baml and should always be present",
        )
    }

    /// Access the `list_files` field builder.
    pub fn property_list_files(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("list_files").expect(
            "AgentToolArgs.list_files is statically defined in .baml and should always be present",
        )
    }

    /// Access the `search_files` field builder.
    pub fn property_search_files(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("search_files")
            .expect("AgentToolArgs.search_files is statically defined in .baml and should always be present")
    }

    /// Access the `web_search` field builder.
    pub fn property_web_search(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("web_search").expect(
            "AgentToolArgs.web_search is statically defined in .baml and should always be present",
        )
    }

    /// Access the `command` field builder.
    pub fn property_command(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("command").expect(
            "AgentToolArgs.command is statically defined in .baml and should always be present",
        )
    }

    /// Access the `cmd` field builder.
    pub fn property_cmd(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("cmd")
            .expect("AgentToolArgs.cmd is statically defined in .baml and should always be present")
    }

    /// Access the `cwd` field builder.
    pub fn property_cwd(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("cwd")
            .expect("AgentToolArgs.cwd is statically defined in .baml and should always be present")
    }

    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning").expect(
            "AgentToolArgs.reasoning is statically defined in .baml and should always be present",
        )
    }

    /// Access the `timeout_ms` field builder.
    pub fn property_timeout_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timeout_ms").expect(
            "AgentToolArgs.timeout_ms is statically defined in .baml and should always be present",
        )
    }

    /// Access the `model` field builder.
    pub fn property_model(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("model").expect(
            "AgentToolArgs.model is statically defined in .baml and should always be present",
        )
    }

    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path").expect(
            "AgentToolArgs.path is statically defined in .baml and should always be present",
        )
    }

    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content").expect(
            "AgentToolArgs.content is statically defined in .baml and should always be present",
        )
    }

    /// Access the `pattern` field builder.
    pub fn property_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pattern").expect(
            "AgentToolArgs.pattern is statically defined in .baml and should always be present",
        )
    }

    /// Access the `file_pattern` field builder.
    pub fn property_file_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("file_pattern")
            .expect("AgentToolArgs.file_pattern is statically defined in .baml and should always be present")
    }

    /// Access the `recursive` field builder.
    pub fn property_recursive(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recursive").expect(
            "AgentToolArgs.recursive is statically defined in .baml and should always be present",
        )
    }

    /// Access the `limit` field builder.
    pub fn property_limit(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("limit").expect(
            "AgentToolArgs.limit is statically defined in .baml and should always be present",
        )
    }

    /// Access the `offset` field builder.
    pub fn property_offset(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("offset").expect(
            "AgentToolArgs.offset is statically defined in .baml and should always be present",
        )
    }

    /// Access the `query` field builder.
    pub fn property_query(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("query").expect(
            "AgentToolArgs.query is statically defined in .baml and should always be present",
        )
    }

    /// Access the `provider` field builder.
    pub fn property_provider(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider").expect(
            "AgentToolArgs.provider is statically defined in .baml and should always be present",
        )
    }

    /// Access the `max_results` field builder.
    pub fn property_max_results(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("max_results").expect(
            "AgentToolArgs.max_results is statically defined in .baml and should always be present",
        )
    }

    /// Access the `time_range` field builder.
    pub fn property_time_range(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("time_range").expect(
            "AgentToolArgs.time_range is statically defined in .baml and should always be present",
        )
    }

    /// Access the `include_domains` field builder.
    pub fn property_include_domains(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("include_domains")
            .expect("AgentToolArgs.include_domains is statically defined in .baml and should always be present")
    }

    /// Access the `exclude_domains` field builder.
    pub fn property_exclude_domains(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("exclude_domains")
            .expect("AgentToolArgs.exclude_domains is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `AgentToolCall` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct AgentToolCallClassBuilder {
    inner: baml::ClassBuilder,
}

impl AgentToolCallClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("AgentToolCall is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `tool_name` field builder.
    pub fn property_tool_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_name").expect(
            "AgentToolCall.tool_name is statically defined in .baml and should always be present",
        )
    }

    /// Access the `tool_args` field builder.
    pub fn property_tool_args(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_args").expect(
            "AgentToolCall.tool_args is statically defined in .baml and should always be present",
        )
    }

    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning").expect(
            "AgentToolCall.reasoning is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `BashToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct BashToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl BashToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("BashToolArgs is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `command` field builder.
    pub fn property_command(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("command").expect(
            "BashToolArgs.command is statically defined in .baml and should always be present",
        )
    }

    /// Access the `cmd` field builder.
    pub fn property_cmd(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("cmd")
            .expect("BashToolArgs.cmd is statically defined in .baml and should always be present")
    }

    /// Access the `cwd` field builder.
    pub fn property_cwd(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("cwd")
            .expect("BashToolArgs.cwd is statically defined in .baml and should always be present")
    }

    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning").expect(
            "BashToolArgs.reasoning is statically defined in .baml and should always be present",
        )
    }

    /// Access the `timeout_ms` field builder.
    pub fn property_timeout_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timeout_ms").expect(
            "BashToolArgs.timeout_ms is statically defined in .baml and should always be present",
        )
    }

    /// Access the `model` field builder.
    pub fn property_model(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("model").expect(
            "BashToolArgs.model is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `CompletionPayload` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct CompletionPayloadClassBuilder {
    inner: baml::ClassBuilder,
}

impl CompletionPayloadClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "CompletionPayload is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `objective_status` field builder.
    pub fn property_objective_status(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective_status")
            .expect("CompletionPayload.objective_status is statically defined in .baml and should always be present")
    }

    /// Access the `objective_fulfilled` field builder.
    pub fn property_objective_fulfilled(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective_fulfilled")
            .expect("CompletionPayload.objective_fulfilled is statically defined in .baml and should always be present")
    }

    /// Access the `completion_reason` field builder.
    pub fn property_completion_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("completion_reason")
            .expect("CompletionPayload.completion_reason is statically defined in .baml and should always be present")
    }

    /// Access the `evidence` field builder.
    pub fn property_evidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("evidence")
            .expect("CompletionPayload.evidence is statically defined in .baml and should always be present")
    }

    /// Access the `unresolved_items` field builder.
    pub fn property_unresolved_items(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("unresolved_items")
            .expect("CompletionPayload.unresolved_items is statically defined in .baml and should always be present")
    }

    /// Access the `recommended_next_action` field builder.
    pub fn property_recommended_next_action(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_next_action")
            .expect("CompletionPayload.recommended_next_action is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `Evidence` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct EvidenceClassBuilder {
    inner: baml::ClassBuilder,
}

impl EvidenceClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Evidence is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `evidence_id` field builder.
    pub fn property_evidence_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("evidence_id").expect(
            "Evidence.evidence_id is statically defined in .baml and should always be present",
        )
    }

    /// Access the `evidence_type` field builder.
    pub fn property_evidence_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("evidence_type").expect(
            "Evidence.evidence_type is statically defined in .baml and should always be present",
        )
    }

    /// Access the `source` field builder.
    pub fn property_source(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("source")
            .expect("Evidence.source is statically defined in .baml and should always be present")
    }

    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("content")
            .expect("Evidence.content is statically defined in .baml and should always be present")
    }

    /// Access the `confidence` field builder.
    pub fn property_confidence(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("confidence").expect(
            "Evidence.confidence is statically defined in .baml and should always be present",
        )
    }

    /// Access the `timestamp` field builder.
    pub fn property_timestamp(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timestamp").expect(
            "Evidence.timestamp is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `ListFilesToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ListFilesToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl ListFilesToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "ListFilesToolArgs is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path").expect(
            "ListFilesToolArgs.path is statically defined in .baml and should always be present",
        )
    }

    /// Access the `recursive` field builder.
    pub fn property_recursive(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recursive")
            .expect("ListFilesToolArgs.recursive is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `Message` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct MessageClassBuilder {
    inner: baml::ClassBuilder,
}

impl MessageClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Message is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `role` field builder.
    pub fn property_role(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("role")
            .expect("Message.role is statically defined in .baml and should always be present")
    }

    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("content")
            .expect("Message.content is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `NextAction` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct NextActionClassBuilder {
    inner: baml::ClassBuilder,
}

impl NextActionClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("NextAction is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `action_type` field builder.
    pub fn property_action_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("action_type").expect(
            "NextAction.action_type is statically defined in .baml and should always be present",
        )
    }

    /// Access the `recommended_capability` field builder.
    pub fn property_recommended_capability(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_capability")
            .expect("NextAction.recommended_capability is statically defined in .baml and should always be present")
    }

    /// Access the `recommended_objective` field builder.
    pub fn property_recommended_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("recommended_objective")
            .expect("NextAction.recommended_objective is statically defined in .baml and should always be present")
    }

    /// Access the `rationale` field builder.
    pub fn property_rationale(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("rationale").expect(
            "NextAction.rationale is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `ObjectiveContract` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ObjectiveContractClassBuilder {
    inner: baml::ClassBuilder,
}

impl ObjectiveContractClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "ObjectiveContract is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `objective_id` field builder.
    pub fn property_objective_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("objective_id")
            .expect("ObjectiveContract.objective_id is statically defined in .baml and should always be present")
    }

    /// Access the `parent_objective_id` field builder.
    pub fn property_parent_objective_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("parent_objective_id")
            .expect("ObjectiveContract.parent_objective_id is statically defined in .baml and should always be present")
    }

    /// Access the `primary_objective` field builder.
    pub fn property_primary_objective(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("primary_objective")
            .expect("ObjectiveContract.primary_objective is statically defined in .baml and should always be present")
    }

    /// Access the `success_criteria` field builder.
    pub fn property_success_criteria(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("success_criteria")
            .expect("ObjectiveContract.success_criteria is statically defined in .baml and should always be present")
    }

    /// Access the `max_tool_calls` field builder.
    pub fn property_max_tool_calls(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("max_tool_calls")
            .expect("ObjectiveContract.max_tool_calls is statically defined in .baml and should always be present")
    }

    /// Access the `timeout_ms` field builder.
    pub fn property_timeout_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timeout_ms")
            .expect("ObjectiveContract.timeout_ms is statically defined in .baml and should always be present")
    }

    /// Access the `attempts_budget` field builder.
    pub fn property_attempts_budget(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("attempts_budget")
            .expect("ObjectiveContract.attempts_budget is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `ReadFileToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ReadFileToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl ReadFileToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("ReadFileToolArgs is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path").expect(
            "ReadFileToolArgs.path is statically defined in .baml and should always be present",
        )
    }

    /// Access the `limit` field builder.
    pub fn property_limit(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("limit").expect(
            "ReadFileToolArgs.limit is statically defined in .baml and should always be present",
        )
    }

    /// Access the `offset` field builder.
    pub fn property_offset(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("offset").expect(
            "ReadFileToolArgs.offset is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `Resume` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ResumeClassBuilder {
    inner: baml::ClassBuilder,
}

impl ResumeClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("Resume is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `name` field builder.
    pub fn property_name(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("name")
            .expect("Resume.name is statically defined in .baml and should always be present")
    }

    /// Access the `email` field builder.
    pub fn property_email(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("email")
            .expect("Resume.email is statically defined in .baml and should always be present")
    }

    /// Access the `experience` field builder.
    pub fn property_experience(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("experience")
            .expect("Resume.experience is statically defined in .baml and should always be present")
    }

    /// Access the `skills` field builder.
    pub fn property_skills(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("skills")
            .expect("Resume.skills is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `SearchFilesToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct SearchFilesToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl SearchFilesToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "SearchFilesToolArgs is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `pattern` field builder.
    pub fn property_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("pattern")
            .expect("SearchFilesToolArgs.pattern is statically defined in .baml and should always be present")
    }

    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path").expect(
            "SearchFilesToolArgs.path is statically defined in .baml and should always be present",
        )
    }

    /// Access the `file_pattern` field builder.
    pub fn property_file_pattern(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("file_pattern")
            .expect("SearchFilesToolArgs.file_pattern is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `StreamChunk` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct StreamChunkClassBuilder {
    inner: baml::ClassBuilder,
}

impl StreamChunkClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("StreamChunk is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `chunk_type` field builder.
    pub fn property_chunk_type(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("chunk_type").expect(
            "StreamChunk.chunk_type is statically defined in .baml and should always be present",
        )
    }

    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content").expect(
            "StreamChunk.content is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `ToolResult` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct ToolResultClassBuilder {
    inner: baml::ClassBuilder,
}

impl ToolResultClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("ToolResult is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `tool_name` field builder.
    pub fn property_tool_name(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("tool_name").expect(
            "ToolResult.tool_name is statically defined in .baml and should always be present",
        )
    }

    /// Access the `success` field builder.
    pub fn property_success(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("success").expect(
            "ToolResult.success is statically defined in .baml and should always be present",
        )
    }

    /// Access the `output` field builder.
    pub fn property_output(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("output")
            .expect("ToolResult.output is statically defined in .baml and should always be present")
    }

    /// Access the `error` field builder.
    pub fn property_error(&self) -> baml::ClassPropertyBuilder {
        self.inner
            .get_property("error")
            .expect("ToolResult.error is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `UnresolvedItem` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct UnresolvedItemClassBuilder {
    inner: baml::ClassBuilder,
}

impl UnresolvedItemClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner
            .as_type()
            .expect("UnresolvedItem is statically defined in .baml and should always have a type")
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `item_id` field builder.
    pub fn property_item_id(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("item_id").expect(
            "UnresolvedItem.item_id is statically defined in .baml and should always be present",
        )
    }

    /// Access the `description` field builder.
    pub fn property_description(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("description")
            .expect("UnresolvedItem.description is statically defined in .baml and should always be present")
    }

    /// Access the `reason` field builder.
    pub fn property_reason(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reason").expect(
            "UnresolvedItem.reason is statically defined in .baml and should always be present",
        )
    }
}

/// Wrapper for the `WebSearchToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WebSearchToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl WebSearchToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "WebSearchToolArgs is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `query` field builder.
    pub fn property_query(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("query").expect(
            "WebSearchToolArgs.query is statically defined in .baml and should always be present",
        )
    }

    /// Access the `provider` field builder.
    pub fn property_provider(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("provider")
            .expect("WebSearchToolArgs.provider is statically defined in .baml and should always be present")
    }

    /// Access the `max_results` field builder.
    pub fn property_max_results(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("max_results")
            .expect("WebSearchToolArgs.max_results is statically defined in .baml and should always be present")
    }

    /// Access the `time_range` field builder.
    pub fn property_time_range(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("time_range")
            .expect("WebSearchToolArgs.time_range is statically defined in .baml and should always be present")
    }

    /// Access the `include_domains` field builder.
    pub fn property_include_domains(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("include_domains")
            .expect("WebSearchToolArgs.include_domains is statically defined in .baml and should always be present")
    }

    /// Access the `exclude_domains` field builder.
    pub fn property_exclude_domains(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("exclude_domains")
            .expect("WebSearchToolArgs.exclude_domains is statically defined in .baml and should always be present")
    }

    /// Access the `timeout_ms` field builder.
    pub fn property_timeout_ms(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("timeout_ms")
            .expect("WebSearchToolArgs.timeout_ms is statically defined in .baml and should always be present")
    }

    /// Access the `model` field builder.
    pub fn property_model(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("model").expect(
            "WebSearchToolArgs.model is statically defined in .baml and should always be present",
        )
    }

    /// Access the `reasoning` field builder.
    pub fn property_reasoning(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("reasoning")
            .expect("WebSearchToolArgs.reasoning is statically defined in .baml and should always be present")
    }
}

/// Wrapper for the `WriteFileToolArgs` class builder.
///
/// Provides type-safe method access to fields defined in the schema.
/// Access fields via methods: `builder.field_name()`

pub struct WriteFileToolArgsClassBuilder {
    inner: baml::ClassBuilder,
}

impl WriteFileToolArgsClassBuilder {
    /// Create wrapper from runtime ClassBuilder.
    pub(crate) fn new(inner: baml::ClassBuilder) -> Self {
        Self { inner }
    }

    /// Get the underlying ClassBuilder.
    pub fn inner(&self) -> &baml::ClassBuilder {
        &self.inner
    }

    /// Get the class as a type definition.
    pub fn r#type(&self) -> baml::TypeDef {
        self.inner.as_type().expect(
            "WriteFileToolArgs is statically defined in .baml and should always have a type",
        )
    }

    // =========================================================================
    // Field Accessors (1:1 with schema field names)
    // =========================================================================

    /// Access the `path` field builder.
    pub fn property_path(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("path").expect(
            "WriteFileToolArgs.path is statically defined in .baml and should always be present",
        )
    }

    /// Access the `content` field builder.
    pub fn property_content(&self) -> baml::ClassPropertyBuilder {
        self.inner.get_property("content").expect(
            "WriteFileToolArgs.content is statically defined in .baml and should always be present",
        )
    }
}
