// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Generated class types.

use super::enums::{EscalationAction, EscalationKind, ReviewStatus, RiskCategory, UrgencyLevel};
use super::*;
use baml::{BamlDecode, BamlEncode};

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct AgentDecision {
    pub action: Action,

    pub tool_calls: Vec<AgentToolCall>,

    pub summary: Option<String>,

    pub reason: Option<String>,
}

impl AsRef<AgentDecision> for AgentDecision {
    fn as_ref(&self) -> &AgentDecision {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct AgentToolArgs {
    pub bash: Option<BashToolArgs>,

    pub read_file: Option<ReadFileToolArgs>,

    pub write_file: Option<WriteFileToolArgs>,

    pub list_files: Option<ListFilesToolArgs>,

    pub search_files: Option<SearchFilesToolArgs>,

    pub web_search: Option<WebSearchToolArgs>,

    pub command: Option<String>,

    pub cmd: Option<String>,

    pub cwd: Option<String>,

    pub reasoning: Option<String>,

    pub timeout_ms: Option<i64>,

    pub model: Option<String>,

    pub path: Option<String>,

    pub content: Option<String>,

    pub pattern: Option<String>,

    pub file_pattern: Option<String>,

    pub recursive: Option<bool>,

    pub limit: Option<i64>,

    pub offset: Option<i64>,

    pub query: Option<String>,

    pub provider: Option<String>,

    pub max_results: Option<i64>,

    pub time_range: Option<String>,

    pub include_domains: Option<Vec<String>>,

    pub exclude_domains: Option<Vec<String>>,

    pub old_text: Option<String>,

    pub new_text: Option<String>,
}

impl AsRef<AgentToolArgs> for AgentToolArgs {
    fn as_ref(&self) -> &AgentToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct AgentToolCall {
    pub tool_name: String,

    pub tool_args: AgentToolArgs,

    pub reasoning: Option<String>,
}

impl AsRef<AgentToolCall> for AgentToolCall {
    fn as_ref(&self) -> &AgentToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct AlternativeAction {
    pub action: EscalationAction,

    pub pros: Vec<String>,

    pub cons: Vec<String>,

    pub estimated_success_rate: f64,
}

impl AsRef<AlternativeAction> for AlternativeAction {
    fn as_ref(&self) -> &AlternativeAction {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct BashToolArgs {
    pub command: Option<String>,

    pub cmd: Option<String>,

    pub cwd: Option<String>,

    pub reasoning: Option<String>,

    pub timeout_ms: Option<i64>,

    pub model: Option<String>,
}

impl AsRef<BashToolArgs> for BashToolArgs {
    fn as_ref(&self) -> &BashToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorBootstrapInput {
    pub raw_objective: String,

    pub available_capabilities: Vec<String>,
}

impl AsRef<ConductorBootstrapInput> for ConductorBootstrapInput {
    fn as_ref(&self) -> &ConductorBootstrapInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorBootstrapOutput {
    pub dispatch_capabilities: Vec<String>,

    pub block_reason: Option<String>,

    pub rationale: String,

    pub confidence: f64,
}

impl AsRef<ConductorBootstrapOutput> for ConductorBootstrapOutput {
    fn as_ref(&self) -> &ConductorBootstrapOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorDecision {
    pub action: ConductorAction,

    pub args: Option<std::collections::HashMap<String, String>>,

    pub reason: String,
}

impl AsRef<ConductorDecision> for ConductorDecision {
    fn as_ref(&self) -> &ConductorDecision {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorDecisionInput {
    pub run_id: String,

    pub objective: String,

    pub document_path: String,

    pub last_error: Option<String>,
}

impl AsRef<ConductorDecisionInput> for ConductorDecisionInput {
    fn as_ref(&self) -> &ConductorDecisionInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorObjectiveRefineInput {
    pub raw_objective: String,

    pub context: Vec<String>,

    pub target_capability: String,
}

impl AsRef<ConductorObjectiveRefineInput> for ConductorObjectiveRefineInput {
    fn as_ref(&self) -> &ConductorObjectiveRefineInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorObjectiveRefineOutput {
    pub refined_objective: String,

    pub success_criteria: Vec<String>,

    pub estimated_steps: i64,

    pub confidence: f64,
}

impl AsRef<ConductorObjectiveRefineOutput> for ConductorObjectiveRefineOutput {
    fn as_ref(&self) -> &ConductorObjectiveRefineOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct DetectedAnomaly {
    pub anomaly_type: String,

    pub severity: String,

    pub description: String,

    pub affected_events: Vec<String>,

    pub pattern_detected: String,
}

impl AsRef<DetectedAnomaly> for DetectedAnomaly {
    fn as_ref(&self) -> &DetectedAnomaly {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct HistoricalResolution {
    pub pattern: String,

    pub successful_resolution: String,

    pub resolution_type: String,
}

impl AsRef<HistoricalResolution> for HistoricalResolution {
    fn as_ref(&self) -> &HistoricalResolution {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ListFilesToolArgs {
    pub path: Option<String>,

    pub recursive: Option<bool>,
}

impl AsRef<ListFilesToolArgs> for ListFilesToolArgs {
    fn as_ref(&self) -> &ListFilesToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct Message {
    pub role: String,

    pub content: String,
}

impl AsRef<Message> for Message {
    fn as_ref(&self) -> &Message {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ReadFileToolArgs {
    pub path: Option<String>,

    pub limit: Option<i64>,

    pub offset: Option<i64>,
}

impl AsRef<ReadFileToolArgs> for ReadFileToolArgs {
    fn as_ref(&self) -> &ReadFileToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ResearcherPlanInput {
    pub objective: String,

    pub current_query: String,

    pub round: i64,

    pub max_rounds: i64,

    pub working_draft_path: String,

    pub last_error: Option<String>,
}

impl AsRef<ResearcherPlanInput> for ResearcherPlanInput {
    fn as_ref(&self) -> &ResearcherPlanInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ResearcherPlanOutput {
    pub action: ResearchAction,

    pub query: Option<String>,

    pub provider: Option<String>,

    pub url: Option<String>,

    pub file_path: Option<String>,

    pub content: Option<String>,

    pub old_text: Option<String>,

    pub new_text: Option<String>,

    pub reason: String,

    pub status: ResearchStatus,
}

impl AsRef<ResearcherPlanOutput> for ResearcherPlanOutput {
    fn as_ref(&self) -> &ResearcherPlanOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct Resume {
    pub name: String,

    pub email: String,

    pub experience: Vec<String>,

    pub skills: Vec<String>,
}

impl AsRef<Resume> for Resume {
    fn as_ref(&self) -> &Resume {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ReviewScope {
    pub start_time: String,

    pub end_time: String,

    pub event_types: Vec<String>,

    pub min_level: String,
}

impl AsRef<ReviewScope> for ReviewScope {
    fn as_ref(&self) -> &ReviewScope {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct RiskItem {
    pub risk_id: String,

    pub category: RiskCategory,

    pub likelihood: f64,

    pub impact: f64,

    pub description: String,

    pub mitigating_factors: Vec<String>,
}

impl AsRef<RiskItem> for RiskItem {
    fn as_ref(&self) -> &RiskItem {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct RunStateSnapshot {
    pub run_id: String,

    pub status: String,

    pub active_call_count: i64,

    pub recent_failures: i64,

    pub elapsed_time_ms: i64,
}

impl AsRef<RunStateSnapshot> for RunStateSnapshot {
    fn as_ref(&self) -> &RunStateSnapshot {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct SearchFilesToolArgs {
    pub pattern: Option<String>,

    pub path: Option<String>,

    pub file_pattern: Option<String>,
}

impl AsRef<SearchFilesToolArgs> for SearchFilesToolArgs {
    fn as_ref(&self) -> &SearchFilesToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct StreamChunk {
    pub chunk_type: String,

    pub content: String,
}

impl AsRef<StreamChunk> for StreamChunk {
    fn as_ref(&self) -> &StreamChunk {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ToolResult {
    pub tool_name: String,

    pub success: bool,

    pub output: String,

    pub error: Option<String>,
}

impl AsRef<ToolResult> for ToolResult {
    fn as_ref(&self) -> &ToolResult {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherEscalation {
    pub escalation_id: String,

    pub run_id: String,

    pub task_id: String,

    pub kind: EscalationKind,

    pub urgency: UrgencyLevel,

    pub affected_calls: Vec<String>,

    pub description: String,

    pub recommended_action: String,

    pub recommended_capability: Option<String>,

    pub recommended_objective: Option<String>,
}

impl AsRef<WatcherEscalation> for WatcherEscalation {
    fn as_ref(&self) -> &WatcherEscalation {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherEvent {
    pub event_id: String,

    pub timestamp: String,

    pub event_type: String,

    pub level: String,

    pub payload: String,

    pub source: String,
}

impl AsRef<WatcherEvent> for WatcherEvent {
    fn as_ref(&self) -> &WatcherEvent {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherLogWindowInput {
    pub window_id: String,

    pub run_id: String,

    pub task_id: String,

    pub events: Vec<WatcherEvent>,

    pub scope: ReviewScope,

    pub review_reason: Option<String>,
}

impl AsRef<WatcherLogWindowInput> for WatcherLogWindowInput {
    fn as_ref(&self) -> &WatcherLogWindowInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherMitigationInput {
    pub escalation: WatcherEscalation,

    pub run_state: RunStateSnapshot,

    pub available_capabilities: Vec<String>,

    pub historical_resolutions: Vec<HistoricalResolution>,
}

impl AsRef<WatcherMitigationInput> for WatcherMitigationInput {
    fn as_ref(&self) -> &WatcherMitigationInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherMitigationOutput {
    pub escalation_action: EscalationAction,

    pub urgency: UrgencyLevel,

    pub recommended_capability: Option<String>,

    pub recommended_objective: Option<String>,

    pub rationale: String,

    pub confidence: f64,

    pub expected_outcome: String,

    pub alternatives: Vec<AlternativeAction>,
}

impl AsRef<WatcherMitigationOutput> for WatcherMitigationOutput {
    fn as_ref(&self) -> &WatcherMitigationOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherReviewOutput {
    pub review_status: ReviewStatus,

    pub escalations: Vec<WatcherEscalation>,

    pub risks: Vec<RiskItem>,

    pub anomalies: Vec<DetectedAnomaly>,

    pub confidence: f64,

    pub rationale: String,
}

impl AsRef<WatcherReviewOutput> for WatcherReviewOutput {
    fn as_ref(&self) -> &WatcherReviewOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WebSearchToolArgs {
    pub query: Option<String>,

    pub provider: Option<String>,

    pub max_results: Option<i64>,

    pub time_range: Option<String>,

    pub include_domains: Option<Vec<String>>,

    pub exclude_domains: Option<Vec<String>>,

    pub timeout_ms: Option<i64>,

    pub model: Option<String>,

    pub reasoning: Option<String>,
}

impl AsRef<WebSearchToolArgs> for WebSearchToolArgs {
    fn as_ref(&self) -> &WebSearchToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WriteFileToolArgs {
    pub path: Option<String>,

    pub content: Option<String>,
}

impl AsRef<WriteFileToolArgs> for WriteFileToolArgs {
    fn as_ref(&self) -> &WriteFileToolArgs {
        self
    }
}
