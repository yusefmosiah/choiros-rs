// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Generated class types.

use super::*;
use baml::{BamlDecode, BamlEncode};

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct AgentDecision {



    pub tool_calls: Vec<Union8BashToolCallOrFetchUrlToolCallOrFileEditToolCallOrFileReadToolCallOrFileWriteToolCallOrFinishedToolCallOrMessageWriterToolCallOrWebSearchToolCall>,



    pub message: String,


}

impl AsRef<AgentDecision> for AgentDecision {
    fn as_ref(&self) -> &AgentDecision {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct AlternativeAction {
    pub action: EscalationAction,

    pub pros: Vec<String>,

    pub cons: Vec<String>,

    pub estimated_success_rate: f64,
}

impl AsRef<AlternativeAction> for AlternativeAction {
    fn as_ref(&self) -> &AlternativeAction {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct BashToolArgs {
    pub command: String,
}

impl AsRef<BashToolArgs> for BashToolArgs {
    fn as_ref(&self) -> &BashToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct BashToolCall {
    pub tool_name: String,

    pub tool_args: BashToolArgs,

    pub reasoning: Option<String>,
}

impl AsRef<BashToolCall> for BashToolCall {
    fn as_ref(&self) -> &BashToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorBootstrapInput {
    pub raw_objective: String,

    pub available_capabilities: Vec<String>,
}

impl AsRef<ConductorBootstrapInput> for ConductorBootstrapInput {
    fn as_ref(&self) -> &ConductorBootstrapInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorBootstrapOutput {
    pub dispatch_capabilities: Vec<String>,

    pub block_reason: Option<String>,

    pub rationale: String,

    pub confidence: f64,
}

impl AsRef<ConductorBootstrapOutput> for ConductorBootstrapOutput {
    fn as_ref(&self) -> &ConductorBootstrapOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorDecision {
    pub action: ConductorAction,

    pub args: Option<std::collections::HashMap<String, String>>,

    pub reason: String,
}

impl AsRef<ConductorDecision> for ConductorDecision {
    fn as_ref(&self) -> &ConductorDecision {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorDecisionInput {
    pub run_id: String,

    pub objective: String,

    pub document_path: String,

    pub last_error: Option<String>,
}

impl AsRef<ConductorDecisionInput> for ConductorDecisionInput {
    fn as_ref(&self) -> &ConductorDecisionInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorObjectiveRefineInput {
    pub raw_objective: String,

    pub context: Vec<String>,

    pub target_capability: String,
}

impl AsRef<ConductorObjectiveRefineInput> for ConductorObjectiveRefineInput {
    fn as_ref(&self) -> &ConductorObjectiveRefineInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ConductorObjectiveRefineOutput {
    pub refined_objective: String,

    pub success_criteria: Vec<String>,

    pub estimated_steps: i64,

    pub confidence: f64,
}

impl AsRef<ConductorObjectiveRefineOutput> for ConductorObjectiveRefineOutput {
    fn as_ref(&self) -> &ConductorObjectiveRefineOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct DetectedAnomaly {
    pub anomaly_type: String,

    pub severity: String,

    pub description: String,

    pub affected_events: Vec<String>,

    pub pattern_detected: String,
}

impl AsRef<DetectedAnomaly> for DetectedAnomaly {
    fn as_ref(&self) -> &DetectedAnomaly {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct FetchUrlToolArgs {
    pub path: String,
}

impl AsRef<FetchUrlToolArgs> for FetchUrlToolArgs {
    fn as_ref(&self) -> &FetchUrlToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct FetchUrlToolCall {
    pub tool_name: String,

    pub tool_args: FetchUrlToolArgs,

    pub reasoning: Option<String>,
}

impl AsRef<FetchUrlToolCall> for FetchUrlToolCall {
    fn as_ref(&self) -> &FetchUrlToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct FileEditToolArgs {
    pub path: String,

    pub old_text: String,

    pub new_text: String,
}

impl AsRef<FileEditToolArgs> for FileEditToolArgs {
    fn as_ref(&self) -> &FileEditToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct FileEditToolCall {
    pub tool_name: String,

    pub tool_args: FileEditToolArgs,

    pub reasoning: Option<String>,
}

impl AsRef<FileEditToolCall> for FileEditToolCall {
    fn as_ref(&self) -> &FileEditToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct FileReadToolArgs {
    pub path: String,
}

impl AsRef<FileReadToolArgs> for FileReadToolArgs {
    fn as_ref(&self) -> &FileReadToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct FileReadToolCall {
    pub tool_name: String,

    pub tool_args: FileReadToolArgs,

    pub reasoning: Option<String>,
}

impl AsRef<FileReadToolCall> for FileReadToolCall {
    fn as_ref(&self) -> &FileReadToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct FileWriteToolArgs {
    pub path: String,

    pub content: String,
}

impl AsRef<FileWriteToolArgs> for FileWriteToolArgs {
    fn as_ref(&self) -> &FileWriteToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct FileWriteToolCall {
    pub tool_name: String,

    pub tool_args: FileWriteToolArgs,

    pub reasoning: Option<String>,
}

impl AsRef<FileWriteToolCall> for FileWriteToolCall {
    fn as_ref(&self) -> &FileWriteToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct FinishedToolArgs {
    pub summary: Option<String>,
}

impl AsRef<FinishedToolArgs> for FinishedToolArgs {
    fn as_ref(&self) -> &FinishedToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct FinishedToolCall {
    pub tool_name: String,

    pub tool_args: FinishedToolArgs,

    pub reasoning: Option<String>,
}

impl AsRef<FinishedToolCall> for FinishedToolCall {
    fn as_ref(&self) -> &FinishedToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct HistoricalResolution {
    pub pattern: String,

    pub successful_resolution: String,

    pub resolution_type: String,
}

impl AsRef<HistoricalResolution> for HistoricalResolution {
    fn as_ref(&self) -> &HistoricalResolution {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct Message {
    pub role: String,

    pub content: String,
}

impl AsRef<Message> for Message {
    fn as_ref(&self) -> &Message {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct MessageWriterToolArgs {
    pub content: String,

    pub mode: String,

    pub path: Option<String>,

    pub mode_arg: Option<String>,
}

impl AsRef<MessageWriterToolArgs> for MessageWriterToolArgs {
    fn as_ref(&self) -> &MessageWriterToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct MessageWriterToolCall {
    pub tool_name: String,

    pub tool_args: MessageWriterToolArgs,

    pub reasoning: Option<String>,
}

impl AsRef<MessageWriterToolCall> for MessageWriterToolCall {
    fn as_ref(&self) -> &MessageWriterToolCall {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ResearcherPlanInput {
    pub objective: String,

    pub current_query: String,

    pub round: i64,

    pub max_rounds: i64,

    pub working_draft_path: String,

    pub last_error: Option<String>,
}

impl AsRef<ResearcherPlanInput> for ResearcherPlanInput {
    fn as_ref(&self) -> &ResearcherPlanInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ResearcherPlanOutput {
    pub action: ResearchAction,

    pub query: Option<String>,

    pub provider: Option<String>,

    pub url: Option<String>,

    pub file_path: Option<String>,

    pub content: Option<String>,

    pub old_text: Option<String>,

    pub new_text: Option<String>,

    pub reason: String,

    pub status: ResearchStatus,
}

impl AsRef<ResearcherPlanOutput> for ResearcherPlanOutput {
    fn as_ref(&self) -> &ResearcherPlanOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct Resume {
    pub name: String,

    pub email: String,

    pub experience: Vec<String>,

    pub skills: Vec<String>,
}

impl AsRef<Resume> for Resume {
    fn as_ref(&self) -> &Resume {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ReviewScope {
    pub start_time: String,

    pub end_time: String,

    pub event_types: Vec<String>,

    pub min_level: String,
}

impl AsRef<ReviewScope> for ReviewScope {
    fn as_ref(&self) -> &ReviewScope {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct RiskItem {
    pub risk_id: String,

    pub category: RiskCategory,

    pub likelihood: f64,

    pub impact: f64,

    pub description: String,

    pub mitigating_factors: Vec<String>,
}

impl AsRef<RiskItem> for RiskItem {
    fn as_ref(&self) -> &RiskItem {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct RunStateSnapshot {
    pub run_id: String,

    pub status: String,

    pub active_call_count: i64,

    pub recent_failures: i64,

    pub elapsed_time_ms: i64,
}

impl AsRef<RunStateSnapshot> for RunStateSnapshot {
    fn as_ref(&self) -> &RunStateSnapshot {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct StreamChunk {
    pub chunk_type: String,

    pub content: String,
}

impl AsRef<StreamChunk> for StreamChunk {
    fn as_ref(&self) -> &StreamChunk {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct ToolResult {
    pub tool_name: String,

    pub success: bool,

    pub output: String,

    pub error: Option<String>,
}

impl AsRef<ToolResult> for ToolResult {
    fn as_ref(&self) -> &ToolResult {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherEscalation {
    pub escalation_id: String,

    pub run_id: String,

    pub task_id: String,

    pub kind: EscalationKind,

    pub urgency: UrgencyLevel,

    pub affected_calls: Vec<String>,

    pub description: String,

    pub recommended_action: String,

    pub recommended_capability: Option<String>,

    pub recommended_objective: Option<String>,
}

impl AsRef<WatcherEscalation> for WatcherEscalation {
    fn as_ref(&self) -> &WatcherEscalation {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherEvent {
    pub event_id: String,

    pub timestamp: String,

    pub event_type: String,

    pub level: String,

    pub payload: String,

    pub source: String,
}

impl AsRef<WatcherEvent> for WatcherEvent {
    fn as_ref(&self) -> &WatcherEvent {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherLogWindowInput {
    pub window_id: String,

    pub run_id: String,

    pub task_id: String,

    pub events: Vec<WatcherEvent>,

    pub scope: ReviewScope,

    pub review_reason: Option<String>,
}

impl AsRef<WatcherLogWindowInput> for WatcherLogWindowInput {
    fn as_ref(&self) -> &WatcherLogWindowInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherMitigationInput {
    pub escalation: WatcherEscalation,

    pub run_state: RunStateSnapshot,

    pub available_capabilities: Vec<String>,

    pub historical_resolutions: Vec<HistoricalResolution>,
}

impl AsRef<WatcherMitigationInput> for WatcherMitigationInput {
    fn as_ref(&self) -> &WatcherMitigationInput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherMitigationOutput {
    pub escalation_action: EscalationAction,

    pub urgency: UrgencyLevel,

    pub recommended_capability: Option<String>,

    pub recommended_objective: Option<String>,

    pub rationale: String,

    pub confidence: f64,

    pub expected_outcome: String,

    pub alternatives: Vec<AlternativeAction>,
}

impl AsRef<WatcherMitigationOutput> for WatcherMitigationOutput {
    fn as_ref(&self) -> &WatcherMitigationOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WatcherReviewOutput {
    pub review_status: ReviewStatus,

    pub escalations: Vec<WatcherEscalation>,

    pub risks: Vec<RiskItem>,

    pub anomalies: Vec<DetectedAnomaly>,

    pub confidence: f64,

    pub rationale: String,
}

impl AsRef<WatcherReviewOutput> for WatcherReviewOutput {
    fn as_ref(&self) -> &WatcherReviewOutput {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WebSearchToolArgs {
    pub query: String,
}

impl AsRef<WebSearchToolArgs> for WebSearchToolArgs {
    fn as_ref(&self) -> &WebSearchToolArgs {
        self
    }
}

#[derive(Debug, Clone, Default, BamlEncode, BamlDecode)]

pub struct WebSearchToolCall {
    pub tool_name: String,

    pub tool_args: WebSearchToolArgs,

    pub reasoning: Option<String>,
}

impl AsRef<WebSearchToolCall> for WebSearchToolCall {
    fn as_ref(&self) -> &WebSearchToolCall {
        self
    }
}
