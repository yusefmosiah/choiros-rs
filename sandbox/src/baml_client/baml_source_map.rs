// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Embedded BAML source files.

use std::collections::HashMap;
use std::sync::OnceLock;

static FILE_MAP: OnceLock<HashMap<String, String>> = OnceLock::new();

/// Get the embedded BAML source files.
pub fn get_baml_files() -> &'static HashMap<String, String> {
    FILE_MAP.get_or_init(|| {
        let mut m = HashMap::new();

        m.insert("agent.baml".to_string(), "// ChoirOS Chat Agent Functions\n// BAML-powered agent functions for planning and response synthesis\n\nfunction Decide(\n  messages: Message[],\n  context: string,\n  available_tools: string\n) -> AgentDecision {\n  client Orchestrator\n  prompt #\"\n    You are ChoirOS, an intelligent AI assistant.\n\n    {{ context }}\n\n    Available Tools:\n    {{ available_tools }}\n\n    Conversation:\n    {{ messages }}\n\n    Decide what to do next:\n    - If more evidence or actions are needed, return one or more tool_calls\n    - If you have enough information, include a `finished` tool call and put the final answer in message\n\n    Tool-use guidelines:\n    - For external, time-sensitive, or verifiable requests, use tools instead of guessing\n    - Resolve relative time references against the current context\n    - Call multiple tools in parallel when independent\n    - If `message_writer` is available, use it for actor-to-actor updates/completion before calling `finished`\n    - For each tool call, use exactly one schema variant matching the tool_name\n    - Include only valid fields for that tool's args and omit absent optional fields\n    - Never emit placeholder keys with null values\n    - Always set message:\n      - With tool calls: brief execution plan for this step\n      - With `finished`: direct final answer\n    - Once you have sufficient evidence, call `finished` and provide the final answer in message\n\n    {{ ctx.output_format(prefix=\"Return only valid JSON.\\n\", or_splitter=\" | \", hoist_classes=true) }}\n  \"#\n}\n\n// Quick response for simple queries (no tool use)\nfunction QuickResponse(\n  user_message: string,\n  conversation_history: string\n) -> string {\n  client FastResponse\n  prompt #\"\n    You are ChoirOS, a helpful AI assistant.\n\n    Conversation History:\n    {{ conversation_history }}\n\n    User: {{ user_message }}\n\n    Provide a brief, helpful response.\n  \"#\n}\n".to_string());

        m.insert("clients.baml".to_string(), "// ChoirOS Chat Agent Clients\n// Semantic client names for role-based model routing.\n// Actual providers are configured at runtime via ClientRegistry.\n\n// Orchestrator: High-quality model for complex reasoning and orchestration\nclient<llm> Orchestrator {\n  provider aws-bedrock\n  retry_policy Exponential\n  options {\n    model \"us.anthropic.claude-opus-4-5-20251101-v1:0\"\n    region \"us-east-1\"\n    // No explicit auth needed - provider auto-detects AWS_BEARER_TOKEN_BEDROCK\n  }\n}\n\n// FastResponse: Fast/cheap model for quick responses and high-volume tasks\nclient<llm> FastResponse {\n  provider anthropic\n  retry_policy Exponential\n  options {\n    api_key env.ZAI_API_KEY\n    base_url \"https://api.z.ai/api/anthropic\"\n    model \"glm-4.7\"\n  }\n}\n\n// Retry policies\nretry_policy Exponential {\n  max_retries 2\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}\n".to_string());

        m.insert("conductor.baml".to_string(), "// ChoirOS Conductor BAML Contracts\n// Orchestration functions for the Conductor actor to manage multi-step agent workflows\n\n// ============================================================================\n// Simplified Decision Types\n// ============================================================================\n\nenum ConductorAction {\n  SpawnWorker\n  AwaitWorker\n  MergeCanon\n  Complete\n  Block\n}\n\nclass ConductorDecision {\n  action ConductorAction\n  args map<string, string>?\n  reason string\n}\n\nclass ConductorDecisionInput {\n  run_id string\n  objective string\n  document_path string\n  last_error string?\n}\n\nfunction ConductorDecide(input: ConductorDecisionInput) -> ConductorDecision {\n  client Orchestrator\n  prompt #\"\n    You are the ChoirOS Conductor, an orchestration AI.\n\n    Current Run:\n    - Run ID: {{ input.run_id }}\n    - Objective: {{ input.objective }}\n    - Document: {{ input.document_path }}\n    {% if input.last_error %}\n    - Last Error: {{ input.last_error }}\n    {% endif %}\n\n    Read the living document at {{ input.document_path }} to understand the current state.\n\n    Decide the next action:\n    - **SpawnWorker**: Dispatch a worker (researcher, terminal) with an objective\n    - **AwaitWorker**: Wait for pending worker calls to complete\n    - **MergeCanon**: Merge completed worker proposals into canon\n    - **Complete**: The objective is achieved\n    - **Block**: Cannot proceed (error or needs human help)\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// ============================================================================\n// Function: ConductorRefineObjective\n// ============================================================================\n\nclass ConductorObjectiveRefineInput {\n  raw_objective string\n  context string[]\n  target_capability string\n}\n\nclass ConductorObjectiveRefineOutput {\n  refined_objective string\n  success_criteria string[]\n  estimated_steps int\n  confidence float\n}\n\nfunction ConductorRefineObjective(input: ConductorObjectiveRefineInput) -> ConductorObjectiveRefineOutput {\n  client Orchestrator\n  prompt #\"\n    You are the ChoirOS Conductor, refining user objectives into clear, actionable tasks for capability workers.\n\n    Raw Objective: {{ input.raw_objective }}\n\n    Target Capability: {{ input.target_capability }}\n\n    Context from Previous Worker Outputs:\n    {{ input.context }}\n\n    Your task is to transform the raw objective into a refined, actionable objective specifically tailored for the target capability.\n\n    Refinement Guidelines:\n    1. Make the objective specific and unambiguous\n    2. Include relevant context from previous outputs\n    3. Frame it in terms the target capability understands\n    4. Define clear success criteria (3-5 specific, measurable outcomes)\n    5. Estimate the number of steps required (1-10)\n    6. Set confidence based on clarity of the refinement (0.0-1.0)\n\n    Success Criteria Guidelines:\n    - Each criterion should be verifiable\n    - Use specific metrics where possible\n    - Include both positive outcomes and negative constraints\n    - Consider edge cases and error conditions\n\n    Example Transformations:\n    - Raw: \"Research this topic\" -> Refined: \"Search for recent academic papers on X published in 2024, extract key findings, and summarize methodology\"\n    - Raw: \"Fix the bug\" -> Refined: \"Analyze the error logs in /var/log/app.log, identify the root cause of the timeout issue, and implement a fix with test coverage\"\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// ============================================================================\n// Function: ConductorBootstrapAgenda\n// ============================================================================\n\nclass ConductorBootstrapInput {\n  raw_objective string\n  available_capabilities string[]\n}\n\nclass ConductorBootstrapOutput {\n  dispatch_capabilities string[]\n  block_reason string?\n  rationale string\n  confidence float\n}\n\nfunction ConductorBootstrapAgenda(input: ConductorBootstrapInput) -> ConductorBootstrapOutput {\n  client Orchestrator\n  prompt #\"\n    You are the ChoirOS Conductor bootstrap policy.\n\n    Choose which capabilities should be dispatched first for a new run.\n\n    Raw Objective: {{ input.raw_objective }}\n    Available Capabilities: {{ input.available_capabilities }}\n\n    Output contract:\n    - dispatch_capabilities may include zero, one, or many capability names.\n    - Only return capability names from available_capabilities.\n    - Conductor routes app-level capabilities (for example: writer, immediate_response), not worker roles.\n    - Do not return worker names such as researcher or terminal unless explicitly present in available_capabilities.\n    - Use immediate_response only for short conversational acknowledgements (for example: hi, ping, quick status checks).\n    - Return zero capabilities when the run should be blocked immediately.\n    - If dispatch_capabilities is empty, block_reason is required.\n    - rationale must explain why these capabilities were selected.\n    - confidence is 0.0-1.0.\n    - Avoid deterministic threshold logic and use semantic task fit.\n\n    {{ ctx.output_format }}\n  \"#\n}\n".to_string());

        m.insert("generators.baml".to_string(), "// BAML Generator for Rust - ChoirOS Chat Agent\n// This generates Rust code for BAML functions\n\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"go\", \"rust\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"rust\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../sandbox/src\"\n\n    // The version of the BAML package you have installed\n    version \"0.217.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode async\n}\n".to_string());

        m.insert("researcher.baml".to_string(), "// ChoirOS Researcher BAML Contracts - DEPRECATED\n//\n// DEPRECATION NOTICE (2026-02-11):\n// The ResearcherActor now uses the unified agent harness (agent_harness module)\n// with the standard Decide function from agent.baml. These types and the\n// ResearcherPlanStep function are kept for backward compatibility but are\n// no longer used by the main researcher loop.\n//\n// The researcher now follows the standard pattern:\n//   DECIDE (via PlanAction/Decide) -> EXECUTE tools -> loop or return\n//\n// Tool execution is handled by ResearcherAdapter which implements AgentAdapter.\n\n// ============================================================================\n// Status Enums (kept for backward compatibility)\n// ============================================================================\n\nenum ResearchStatus {\n  Ongoing    // Still researching, gathering information\n  Complete   // Satisfied with the answer\n  Blocked    // Cannot proceed (insufficient info, access issues, etc.)\n}\n\n// ============================================================================\n// Planning Types (kept for backward compatibility)\n// ============================================================================\n\nclass ResearcherPlanInput {\n  objective string\n  current_query string\n  round int\n  max_rounds int\n  working_draft_path string  // Path to the current working draft file\n  last_error string?\n}\n\nclass ResearcherPlanOutput {\n  action ResearchAction        // What to do next\n  query string?                // If searching\n  provider string?             // Search provider hint\n  url string?                  // If fetching\n  file_path string?            // If reading/writing file\n  content string?              // If writing to file\n  old_text string?             // If editing file (text to replace)\n  new_text string?             // If editing file (replacement text)\n  reason string                // Why this action was chosen\n  status ResearchStatus        // Current research status\n}\n\nenum ResearchAction {\n  Search       // Perform web search\n  FetchUrl     // Fetch specific URL\n  FileRead     // Read local file\n  FileWrite    // Write/create file\n  FileEdit     // Edit existing file\n  Complete     // Research is complete\n  Block        // Cannot proceed\n}\n\n// ============================================================================\n// Functions (DEPRECATED - use Decide from agent.baml instead)\n// ============================================================================\n\nfunction ResearcherPlanStep(input: ResearcherPlanInput) -> ResearcherPlanOutput {\n  client FastResponse\n  prompt #\"\n    DEPRECATED: This function is kept for backward compatibility.\n    The ResearcherActor now uses the unified agent harness with Decide.\n\n    You are the ChoirOS Researcher. Your job is to gather information and maintain a working draft document.\n\n    Objective: {{ input.objective }}\n    Current Query: {{ input.current_query }}\n    Round: {{ input.round }} / {{ input.max_rounds }}\n    Working Draft: {{ input.working_draft_path }}\n    Last Error: {{ input.last_error }}\n\n    Available Actions:\n    - Search: Use web_search with query and optional provider (tavily, brave, exa, auto)\n    - FetchUrl: Use fetch_url to retrieve content from a specific URL\n    - FileRead: Read an existing file to reference previous research or context\n    - FileWrite: Create or overwrite a file (usually your working draft)\n    - FileEdit: Modify specific text in an existing file (preserves what you don't change)\n    - Complete: Mark research as done when you have a satisfactory answer\n    - Block: Mark as blocked if you cannot proceed\n\n    Working Document Strategy:\n    - Start by writing an initial draft with your plan\n    - Update the draft as you discover new information\n    - Use FileEdit to refine specific sections without rewriting everything\n    - The draft should evolve from \"plan\" → \"notes\" → \"findings\" → \"final answer\"\n    - Write in freeform markdown - no forced structure\n    - Put the most important finding first (don't bury the lede)\n\n    Guidelines:\n    - Be concise in your writing - update the draft frequently\n    - Cite sources inline as markdown links: [title](url)\n    - If a search returns little, try a different query or provider\n    - Read existing files if the objective references local content\n    - When Complete, ensure the working draft contains your final answer\n\n    {{ ctx.output_format }}\n  \"#\n}\n".to_string());

        m.insert("resume.baml".to_string(), "// Defining a data model.\nclass Resume {\n  name string\n  email string\n  experience string[]\n  skills string[]\n}\n\n// Create a function to extract the resume from a string.\nfunction ExtractResume(resume: string) -> Resume {\n  // Specify a client as provider/model-name\n  // You can also use custom LLM params with a custom client name from clients.baml like \"client CustomGPT5\" or \"client CustomSonnet4\"\n  client \"openai-responses/gpt-5-mini\" // Set OPENAI_API_KEY to use this client.\n  prompt #\"\n    Extract from this content:\n    {{ resume }}\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n\n\n// Test the function with a sample resume. Open the VSCode playground to run this.\ntest vaibhav_resume {\n  functions [ExtractResume]\n  args {\n    resume #\"\n      Vaibhav Gupta\n      vbv@boundaryml.com\n\n      Experience:\n      - Founder at BoundaryML\n      - CV Engineer at Google\n      - CV Engineer at Microsoft\n\n      Skills:\n      - Rust\n      - C++\n    \"#\n  }\n}\n".to_string());

        m.insert("types.baml".to_string(), "// ChoirOS Chat Agent Types\n// Core types for BAML-powered chat agent with tool execution\n\n// Message in conversation\nclass Message {\n  role string\n  content string\n}\n\nclass BashToolArgs {\n  command string\n}\n\nclass WebSearchToolArgs {\n  query string\n}\n\nclass FetchUrlToolArgs {\n  path string\n}\n\nclass FileReadToolArgs {\n  path string\n}\n\nclass FileWriteToolArgs {\n  path string\n  content string\n}\n\nclass FileEditToolArgs {\n  path string\n  old_text string\n  new_text string\n}\n\nclass MessageWriterToolArgs {\n  content string\n  mode string\n  path string?\n  mode_arg string?\n}\n\nclass FinishedToolArgs {\n  summary string?\n}\n\nclass BashToolCall {\n  tool_name \"bash\"\n  tool_args BashToolArgs\n  reasoning string?\n}\n\nclass WebSearchToolCall {\n  tool_name \"web_search\"\n  tool_args WebSearchToolArgs\n  reasoning string?\n}\n\nclass FetchUrlToolCall {\n  tool_name \"fetch_url\"\n  tool_args FetchUrlToolArgs\n  reasoning string?\n}\n\nclass FileReadToolCall {\n  tool_name \"file_read\"\n  tool_args FileReadToolArgs\n  reasoning string?\n}\n\nclass FileWriteToolCall {\n  tool_name \"file_write\"\n  tool_args FileWriteToolArgs\n  reasoning string?\n}\n\nclass FileEditToolCall {\n  tool_name \"file_edit\"\n  tool_args FileEditToolArgs\n  reasoning string?\n}\n\nclass MessageWriterToolCall {\n  tool_name \"message_writer\"\n  tool_args MessageWriterToolArgs\n  reasoning string?\n}\n\nclass FinishedToolCall {\n  tool_name \"finished\"\n  tool_args FinishedToolArgs\n  reasoning string?\n}\n\n// Simplified agent decision - what to do next\nclass AgentDecision {\n  tool_calls (BashToolCall | WebSearchToolCall | FetchUrlToolCall | FileReadToolCall | FileWriteToolCall | FileEditToolCall | MessageWriterToolCall | FinishedToolCall)[]  // Completion requires a finished tool call\n  message string\n}\n\n// Result of executing a tool\nclass ToolResult {\n  tool_name string\n  success bool\n  output string\n  error string?\n}\n\n// Streaming chunk types for WebSocket\nclass StreamChunk {\n  chunk_type string // \"thinking\", \"tool_call\", \"tool_result\", \"response\", \"error\"\n  content string\n}\n".to_string());

        m.insert("watcher.baml".to_string(), "// ChoirOS Watcher BAML Contracts\n// Event-log review and escalation functions for the Watcher actor\n//\n// The Watcher provides deterministic detection/alerting over logs.\n// These BAML functions enable LLM-powered review of event windows for\n// anomaly detection and mitigation recommendations.\n\n// ============================================================================\n// Input Types\n// ============================================================================\n\nclass WatcherLogWindowInput {\n  window_id string\n  run_id string\n  task_id string\n  events WatcherEvent[]\n  scope ReviewScope\n  review_reason string?  // Why this window is being reviewed\n}\n\nclass WatcherEvent {\n  event_id string\n  timestamp string\n  event_type string\n  level string  // info, warn, error, critical\n  payload string\n  source string  // which component emitted\n}\n\nclass ReviewScope {\n  start_time string\n  end_time string\n  event_types string[]\n  min_level string\n}\n\n// ============================================================================\n// Output Types - Review\n// ============================================================================\n\nenum ReviewStatus {\n  Clean\n  IssuesDetected\n  Critical\n  Inconclusive\n}\n\nenum EscalationKind {\n  FailureSpike\n  TimeoutPattern\n  ResourceExhaustion\n  SecurityConcern\n  CostAnomaly\n  StalledWorkflow\n  Other\n}\n\nenum UrgencyLevel {\n  Low\n  Medium\n  High\n  Critical\n}\n\nenum RiskCategory {\n  Operational\n  Technical\n  Security\n  Cost\n  Compliance\n}\n\nclass WatcherReviewOutput {\n  review_status ReviewStatus\n  escalations WatcherEscalation[]\n  risks RiskItem[]\n  anomalies DetectedAnomaly[]\n  confidence float\n  rationale string\n}\n\nclass WatcherEscalation {\n  escalation_id string\n  run_id string\n  task_id string\n  kind EscalationKind\n  urgency UrgencyLevel\n  affected_calls string[]\n  description string\n  recommended_action string\n  recommended_capability string?\n  recommended_objective string?\n}\n\nclass RiskItem {\n  risk_id string\n  category RiskCategory\n  likelihood float  // 0.0-1.0\n  impact float  // 0.0-1.0\n  description string\n  mitigating_factors string[]\n}\n\nclass DetectedAnomaly {\n  anomaly_type string\n  severity string\n  description string\n  affected_events string[]\n  pattern_detected string\n}\n\n// ============================================================================\n// Input Types - Mitigation\n// ============================================================================\n\nclass WatcherMitigationInput {\n  escalation WatcherEscalation\n  run_state RunStateSnapshot\n  available_capabilities string[]\n  historical_resolutions HistoricalResolution[]\n}\n\nclass RunStateSnapshot {\n  run_id string\n  status string\n  active_call_count int\n  recent_failures int\n  elapsed_time_ms int\n}\n\nclass HistoricalResolution {\n  pattern string\n  successful_resolution string\n  resolution_type string\n}\n\n// ============================================================================\n// Output Types - Mitigation\n// ============================================================================\n\nenum EscalationAction {\n  NotifyConductor\n  RequestHumanReview\n  AutoRetry\n  ScaleResources\n  TerminateRun\n  ContinueMonitoring\n  EscalateToOnCall\n}\n\nclass WatcherMitigationOutput {\n  escalation_action EscalationAction\n  urgency UrgencyLevel\n  recommended_capability string?\n  recommended_objective string?\n  rationale string\n  confidence float\n  expected_outcome string\n  alternatives AlternativeAction[]\n}\n\nclass AlternativeAction {\n  action EscalationAction\n  pros string[]\n  cons string[]\n  estimated_success_rate float\n}\n\n// ============================================================================\n// Function 1: WatcherReviewLogWindow\n// ============================================================================\n\nfunction WatcherReviewLogWindow(input: WatcherLogWindowInput) -> WatcherReviewOutput {\n  client FastResponse\n  prompt #\"\n    You are the ChoirOS Watcher, an AI that reviews event logs for anomalies,\n    failures, and concerning patterns.\n\n    Your role is deterministic detection over logs - you identify issues that\n    may require escalation to the Conductor or human operators.\n\n    Window ID: {{ input.window_id }}\n    Run ID: {{ input.run_id }}\n    Task ID: {{ input.task_id }}\n\n    Review Reason: {{ input.review_reason }}\n\n    Review Scope:\n    - Start Time: {{ input.scope.start_time }}\n    - End Time: {{ input.scope.end_time }}\n    - Event Types: {{ input.scope.event_types }}\n    - Minimum Level: {{ input.scope.min_level }}\n\n    Events to Review ({{ input.events | length }} events):\n    {{ input.events }}\n\n    Review Guidelines:\n\n    1. **ReviewStatus Classification**:\n       - Clean: No issues detected, normal operation\n       - IssuesDetected: Minor issues found, may need attention\n       - Critical: Serious problems requiring immediate escalation\n       - Inconclusive: Cannot determine from available data\n\n    2. **Escalation Detection** - Create escalations for:\n       - FailureSpike: Multiple failures in short window\n       - TimeoutPattern: Repeated timeout errors\n       - ResourceExhaustion: High resource usage or limits hit\n       - SecurityConcern: Suspicious activity or auth failures\n       - CostAnomaly: Unexpected cost patterns\n       - StalledWorkflow: Tasks not progressing\n       - Other: Unclassified but concerning patterns\n\n    3. **Risk Assessment**:\n       - Evaluate likelihood (0.0-1.0) and impact (0.0-1.0)\n       - Categories: Operational, Technical, Security, Cost, Compliance\n       - List mitigating factors that reduce risk\n\n    4. **Anomaly Detection**:\n       - Identify unusual patterns in event sequences\n       - Note severity and affected events\n       - Describe the pattern detected (e.g., \"retry storm\", \"cascade failure\")\n\n    5. **Escalation Recommendations**:\n       - recommended_action: Clear, actionable next step\n       - recommended_capability: Which capability should handle this (if known)\n       - recommended_objective: What objective to assign (if applicable)\n       - urgency: Low, Medium, High, or Critical\n\n    Output Requirements:\n    - Use exact enum values for ReviewStatus, EscalationKind, UrgencyLevel, RiskCategory\n    - Confidence score 0.0-1.0 based on clarity of findings\n    - Provide clear rationale for all escalations and risks\n    - affected_calls should reference specific call IDs from events\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// ============================================================================\n// Function 2: WatcherRecommendMitigation\n// ============================================================================\n\nfunction WatcherRecommendMitigation(input: WatcherMitigationInput) -> WatcherMitigationOutput {\n  client FastResponse\n  prompt #\"\n    You are the ChoirOS Watcher, recommending mitigation actions for detected issues.\n\n    Your role is to select the best action given an escalation and current run state,\n    including when to auto-retry vs request human review.\n\n    Escalation Details:\n    - ID: {{ input.escalation.escalation_id }}\n    - Kind: {{ input.escalation.kind }}\n    - Urgency: {{ input.escalation.urgency }}\n    - Description: {{ input.escalation.description }}\n    - Affected Calls: {{ input.escalation.affected_calls }}\n    - Recommended Action: {{ input.escalation.recommended_action }}\n    - Recommended Capability: {{ input.escalation.recommended_capability }}\n    - Recommended Objective: {{ input.escalation.recommended_objective }}\n\n    Current Run State:\n    - Run ID: {{ input.run_state.run_id }}\n    - Status: {{ input.run_state.status }}\n    - Active Calls: {{ input.run_state.active_call_count }}\n    - Recent Failures: {{ input.run_state.recent_failures }}\n    - Elapsed Time (ms): {{ input.run_state.elapsed_time_ms }}\n\n    Available Capabilities:\n    {{ input.available_capabilities }}\n\n    Historical Resolutions (similar patterns and their outcomes):\n    {{ input.historical_resolutions }}\n\n    Mitigation Guidelines:\n\n    1. **EscalationAction Selection**:\n       - NotifyConductor: Wake the Conductor for orchestration decision\n       - RequestHumanReview: Human judgment needed (ambiguous, high-stakes)\n       - AutoRetry: Safe to retry automatically (transient failures)\n       - ScaleResources: Increase resources (resource exhaustion)\n       - TerminateRun: Stop the run (unrecoverable, dangerous)\n       - ContinueMonitoring: Watch but don't act yet (inconclusive)\n       - EscalateToOnCall: Page the on-call engineer (critical production issue)\n\n    2. **Decision Matrix**:\n       - Transient failures (network, timeout) + low retry count -> AutoRetry\n       - Resource exhaustion + scaling available -> ScaleResources\n       - Ambiguous situation + high stakes -> RequestHumanReview\n       - Conductor available + complex coordination needed -> NotifyConductor\n       - Critical urgency + production impact -> EscalateToOnCall\n       - Unclear pattern + no historical success -> ContinueMonitoring\n\n    3. **Alternative Actions**:\n       - List 2-3 alternative actions with pros/cons\n       - Estimate success rate for each alternative\n       - Explain why the primary action was chosen\n\n    4. **Capability/Objectives**:\n       - recommended_capability: Which capability to invoke (if action requires it)\n       - recommended_objective: Clear objective statement for the capability\n       - These flow into the Conductor wake lane for orchestration\n\n    Output Requirements:\n    - Use exact enum values for EscalationAction and UrgencyLevel\n    - Confidence score 0.0-1.0 based on certainty of recommendation\n    - Provide clear rationale linking escalation to chosen action\n    - expected_outcome: What should happen if action is taken\n    - Include at least 2 alternatives with honest pros/cons\n\n    {{ ctx.output_format }}\n  \"#\n}\n".to_string());

        m
    })
}
