// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Embedded BAML source files.

use std::collections::HashMap;
use std::sync::OnceLock;

static FILE_MAP: OnceLock<HashMap<String, String>> = OnceLock::new();

/// Get the embedded BAML source files.
pub fn get_baml_files() -> &'static HashMap<String, String> {
    FILE_MAP.get_or_init(|| {
        let mut m = HashMap::new();

        m.insert("agent.baml".to_string(), "// ChoirOS Chat Agent Functions\n// BAML-powered agent functions for planning and response synthesis\n\n// Main agent planning function - determines what to do based on conversation\nfunction PlanAction(\n  messages: Message[],\n  system_context: string,\n  available_tools: string\n) -> AgentPlan {\n  client ClaudeBedrock\n  prompt #\"\n    You are ChoirOS, an intelligent AI assistant in a web desktop environment.\n\n    {{ system_context }}\n\n    Available Tools:\n    {{ available_tools }}\n\n    Conversation History:\n    {{ messages }}\n\n    Think step by step about what to do:\n    1. Analyze the user's request\n    2. Determine if you need to use tools or can respond directly\n    3. If using tools, specify which ones with clear reasoning\n    4. Track objective_status using ObjectiveStatus enum values (satisfied, in_progress, blocked)\n    5. Set plan_mode using PlanMode enum values (call_tools, finalize, escalate)\n    6. Provide a confidence score (0.0-1.0) in your plan\n\n    Tool-use policy:\n    - For external, time-sensitive, or otherwise verifiable requests, attempt tools instead of guessing.\n    - Resolve relative time references against the timestamp in system context, and use explicit dates when that improves clarity.\n    - When one tool cannot fully answer the request, call additional tools in sequence. Once evidence is sufficient, provide a direct final_response immediately (no extra synthesis/planning step).\n    - If the user asks for command execution, prefer a bash tool call when safe.\n    - Do not claim tool/resource limits unless a relevant tool call was attempted and failed.\n    - If a delegated task is running asynchronously, avoid stale status text after completion and provide a final answer once results are available.\n    - On failure, report concrete errors and next-best fallback options.\n    - If delegated output reports objective_status=complete or satisfied, do not call additional tools.\n\n    Objective contract:\n    - objective_status must be one of the ObjectiveStatus enum values: satisfied, in_progress, blocked.\n    - Use the exact snake_case enum values: \"satisfied\", \"in_progress\", \"blocked\".\n    - Use satisfied only when the user's original request is directly answered now.\n    - If objective_status is satisfied: final_response is required and tool_calls must be empty.\n    - If objective_status is in_progress: final_response is prohibited; provide at least one next tool_call when possible.\n    - If objective_status is blocked: final_response and tool_calls are prohibited; completion_reason is required.\n    - Keep trying alternate strategies before blocked when tools are still available.\n    - Before final_response, verify it answers the original user question, not just what tools did.\n    - Never output meta-responses like \"Would you like me to search?\" when tool evidence already exists.\n\n    Plan mode:\n    - plan_mode must be one of the PlanMode enum values: call_tools, finalize, escalate.\n    - Use the exact snake_case enum values: \"call_tools\", \"finalize\", \"escalate\".\n    - Use call_tools when you need to invoke tools to gather more information.\n    - Use finalize when you have sufficient information to provide a final response.\n    - Use escalate when you cannot complete the request and need to escalate to a higher capability.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Synthesize final response after tool execution\nfunction SynthesizeResponse(\n  user_prompt: string,\n  tool_results: ToolResult[],\n  conversation_context: string\n) -> string {\n  client ClaudeBedrock\n  prompt #\"\n    You are ChoirOS, an AI assistant. Synthesize a helpful, natural response.\n\n    User Request: {{ user_prompt }}\n\n    Conversation Context:\n    {{ conversation_context }}\n\n    Tool Results:\n    {{ tool_results }}\n\n    Based on the user's request and the tool results, provide a clear, helpful response.\n    Acknowledge what was done and answer the user's question concisely.\n  \"#\n}\n\n// Quick response for simple queries (no tool use)\nfunction QuickResponse(\n  user_message: string,\n  conversation_history: string\n) -> string {\n  client GLM47\n  prompt #\"\n    You are ChoirOS, a helpful AI assistant.\n\n    Conversation History:\n    {{ conversation_history }}\n\n    User: {{ user_message }}\n\n    Provide a brief, helpful response.\n  \"#\n}\n".to_string());

        m.insert("clients.baml".to_string(), "// ChoirOS Chat Agent Clients\n// Define both model providers: ClaudeBedrock (AWS) and GLM47 (Z.ai)\n\n// AWS Bedrock Claude configuration\n// Authentication: Automatically reads AWS_BEARER_TOKEN_BEDROCK from environment\n// AWS introduced API key auth in July 2025 - BAML's aws-bedrock provider supports this natively\nclient<llm> ClaudeBedrock {\n  provider aws-bedrock\n  retry_policy Exponential\n  options {\n    model \"us.anthropic.claude-opus-4-5-20251101-v1:0\"\n    region \"us-east-1\"\n    // No explicit auth needed - provider auto-detects AWS_BEARER_TOKEN_BEDROCK\n  }\n}\n\n// Z.ai GLM4.7 configuration using Anthropic-compatible API\nclient<llm> GLM47 {\n  provider anthropic\n  retry_policy Exponential\n  options {\n    api_key env.ZAI_API_KEY\n    base_url \"https://api.z.ai/api/anthropic\"\n    model \"glm-4.7\"\n  }\n}\n\n// Retry policies\nretry_policy Exponential {\n  max_retries 2\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}\n".to_string());

        m.insert("conductor.baml".to_string(), "// ChoirOS Conductor BAML Contracts\n// Orchestration functions for the Conductor actor to manage multi-step agent workflows\n\n// ============================================================================\n// Decision Types\n// ============================================================================\n\nenum DecisionType {\n  Dispatch\n  Retry\n  SpawnFollowup\n  Continue\n  Complete\n  Block\n}\n\nenum TerminalityStatus {\n  Complete\n  Blocked\n  Continue\n}\n\n// ============================================================================\n// Supporting Types\n// ============================================================================\n\nclass ConductorAgendaItem {\n  id string\n  capability string\n  objective string\n  dependencies string[]\n  status string\n  priority int\n}\n\nclass ConductorCapabilityCall {\n  call_id string\n  agenda_item_id string\n  capability string\n  objective string\n  status string\n}\n\nclass ConductorArtifact {\n  artifact_id string\n  name string\n  content_type string\n  summary string\n}\n\nclass FollowupRecommendation {\n  capability string\n  objective string\n  priority int\n  rationale string\n}\n\nclass WorkerOutput {\n  call_id string\n  agenda_item_id string\n  status string\n  result_summary string\n  artifacts_produced ConductorArtifact[]\n  followup_recommendations FollowupRecommendation[]\n}\n\nclass EventSummary {\n  event_id string\n  event_type string\n  timestamp string\n  payload string\n}\n\nclass RetryPolicy {\n  max_attempts int\n  backoff_strategy string\n}\n\n// ============================================================================\n// Function 1: ConductorDecideNextAction\n// ============================================================================\n\nclass ConductorDecisionInput {\n  run_id string\n  task_id string\n  objective string\n  run_status string\n  agenda ConductorAgendaItem[]\n  active_calls ConductorCapabilityCall[]\n  artifacts ConductorArtifact[]\n  recent_events EventSummary[]\n  worker_outputs WorkerOutput[]\n}\n\nclass ConductorDecisionOutput {\n  decision_type DecisionType\n  target_agenda_item_ids string[]\n  new_agenda_items ConductorAgendaItem[]\n  capability string?\n  objective string?\n  retry_policy RetryPolicy?\n  completion_reason string?\n  confidence float\n  rationale string\n}\n\nfunction ConductorDecideNextAction(input: ConductorDecisionInput) -> ConductorDecisionOutput {\n  client ClaudeBedrock\n  prompt #\"\n    You are the ChoirOS Conductor, an orchestration AI that manages multi-step agent workflows.\n\n    Your role is to analyze the current run state and decide the next orchestration action.\n\n    Current Run State:\n    - Run ID: {{ input.run_id }}\n    - Task ID: {{ input.task_id }}\n    - Objective: {{ input.objective }}\n    - Run Status: {{ input.run_status }}\n\n    Agenda Items:\n    {{ input.agenda }}\n\n    Active Calls:\n    {{ input.active_calls }}\n\n    Artifacts Collected:\n    {{ input.artifacts }}\n\n    Recent Events:\n    {{ input.recent_events }}\n\n    Worker Outputs:\n    {{ input.worker_outputs }}\n\n    Analyze the current state and decide the next action:\n\n    1. **Dispatch** - Start a new capability call when:\n       - There are agenda items with status \"ready\" (dependencies satisfied)\n       - No conflicting active calls exist\n       - The objective requires more work\n\n    2. **Retry** - Retry a failed call when:\n       - A call failed with a recoverable error\n       - Retry budget has not been exhausted\n       - Adjusted parameters might succeed\n\n    3. **SpawnFollowup** - Add new agenda items when:\n       - Worker outputs recommend follow-up capabilities\n       - New requirements discovered during execution\n       - Sub-tasks needed to complete the objective\n\n    4. **Continue** - Wait for in-flight calls when:\n       - Active calls are still running\n       - No ready agenda items can be started yet\n       - Waiting for dependencies to complete\n\n    5. **Complete** - Mark run as finished when:\n       - All agenda items are completed\n       - The original objective is achieved\n       - Artifacts satisfy success criteria\n\n    6. **Block** - Mark run as blocked when:\n       - Unrecoverable errors occurred\n       - Human intervention is required\n       - Objective cannot be achieved with available capabilities\n\n    Decision Guidelines:\n    - Always check dependencies before dispatching\n    - Consider priority when selecting agenda items\n    - Set confidence based on clarity of the decision (0.0-1.0)\n    - Provide clear rationale for observability\n    - Use exact enum values for decision_type: Dispatch, Retry, SpawnFollowup, Continue, Complete, Block\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// ============================================================================\n// Function 2: ConductorRefineObjective\n// ============================================================================\n\nclass ConductorObjectiveRefineInput {\n  raw_objective string\n  context WorkerOutput[]\n  target_capability string\n}\n\nclass ConductorObjectiveRefineOutput {\n  refined_objective string\n  success_criteria string[]\n  estimated_steps int\n  confidence float\n}\n\nfunction ConductorRefineObjective(input: ConductorObjectiveRefineInput) -> ConductorObjectiveRefineOutput {\n  client ClaudeBedrock\n  prompt #\"\n    You are the ChoirOS Conductor, refining user objectives into clear, actionable tasks for capability workers.\n\n    Raw Objective: {{ input.raw_objective }}\n\n    Target Capability: {{ input.target_capability }}\n\n    Context from Previous Worker Outputs:\n    {{ input.context }}\n\n    Your task is to transform the raw objective into a refined, actionable objective specifically tailored for the target capability.\n\n    Refinement Guidelines:\n    1. Make the objective specific and unambiguous\n    2. Include relevant context from previous outputs\n    3. Frame it in terms the target capability understands\n    4. Define clear success criteria (3-5 specific, measurable outcomes)\n    5. Estimate the number of steps required (1-10)\n    6. Set confidence based on clarity of the refinement (0.0-1.0)\n\n    Success Criteria Guidelines:\n    - Each criterion should be verifiable\n    - Use specific metrics where possible\n    - Include both positive outcomes and negative constraints\n    - Consider edge cases and error conditions\n\n    Example Transformations:\n    - Raw: \"Research this topic\" -> Refined: \"Search for recent academic papers on X published in 2024, extract key findings, and summarize methodology\"\n    - Raw: \"Fix the bug\" -> Refined: \"Analyze the error logs in /var/log/app.log, identify the root cause of the timeout issue, and implement a fix with test coverage\"\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// ============================================================================\n// Function 3: ConductorAssessTerminality\n// ============================================================================\n\nclass ConductorTerminalityInput {\n  run_id string\n  agenda ConductorAgendaItem[]\n  artifacts ConductorArtifact[]\n  original_objective string\n}\n\nclass ConductorTerminalityOutput {\n  terminality_status TerminalityStatus\n  reason string\n  confidence float\n}\n\nfunction ConductorAssessTerminality(input: ConductorTerminalityInput) -> ConductorTerminalityOutput {\n  client ClaudeBedrock\n  prompt #\"\n    You are the ChoirOS Conductor, assessing whether a workflow run has reached a terminal state.\n\n    Run ID: {{ input.run_id }}\n\n    Original Objective: {{ input.original_objective }}\n\n    Current Agenda State:\n    {{ input.agenda }}\n\n    Artifacts Collected:\n    {{ input.artifacts }}\n\n    Assess whether the run should:\n\n    1. **Complete** - The objective has been achieved when:\n       - All agenda items are completed successfully\n       - Artifacts satisfy the original objective\n       - Success criteria have been met\n       - No further work is needed\n\n    2. **Blocked** - The run is blocked when:\n       - One or more agenda items failed and cannot be retried\n       - Required dependencies are unavailable\n       - Human intervention is needed to proceed\n       - The objective cannot be achieved with current resources\n\n    3. **Continue** - The run should continue when:\n       - Agenda items are still pending or in progress\n       - Failed items can be retried\n       - Additional work is needed to achieve the objective\n       - Follow-up tasks have been spawned\n\n    Assessment Guidelines:\n    - Review the original objective carefully\n    - Check if artifacts adequately address the objective\n    - Consider partial success scenarios\n    - Set confidence based on clarity of the assessment (0.0-1.0)\n    - Provide specific reason referencing agenda state and artifacts\n    - Use exact enum values for terminality_status: Complete, Blocked, Continue\n\n    {{ ctx.output_format }}\n  \"#\n}\n".to_string());

        m.insert("generators.baml".to_string(), "// BAML Generator for Rust - ChoirOS Chat Agent\n// This generates Rust code for BAML functions\n\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"go\", \"rust\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"rust\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../sandbox/src\"\n\n    // The version of the BAML package you have installed\n    version \"0.217.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode async\n}\n".to_string());

        m.insert("researcher.baml".to_string(), "// ChoirOS Researcher BAML Contracts\n// Agentic planner + synthesis authority for researcher loops.\n\nenum ResearcherNextAction {\n  Search\n  FetchUrl\n  Complete\n  Block\n}\n\nenum ResearcherObjectiveStatus {\n  Complete\n  Incomplete\n  Blocked\n}\n\nclass ResearcherProviderCallSummary {\n  provider string\n  latency_ms int\n  result_count int\n  succeeded bool\n  error string?\n}\n\nclass ResearcherCitationInput {\n  provider string\n  title string\n  url string\n  snippet string\n  published_at string?\n  score float?\n}\n\nclass ResearcherFetchedPageInput {\n  url string\n  status_code int\n  content_excerpt string\n  success bool\n}\n\nclass ResearcherPlanInput {\n  objective string\n  current_query string\n  round int\n  max_rounds int\n  provider_hint string?\n  max_results_hint int?\n  last_error string?\n  provider_calls ResearcherProviderCallSummary[]\n  citations ResearcherCitationInput[]\n  fetched_pages ResearcherFetchedPageInput[]\n}\n\nclass ResearcherPlanOutput {\n  action ResearcherNextAction\n  query string?\n  provider string?\n  fetch_url string?\n  max_results int?\n  time_range string?\n  rationale string\n  confidence float\n  completion_reason string?\n  recommended_next_capability string?\n  recommended_next_objective string?\n}\n\nclass ResearcherSynthesisInput {\n  objective string\n  query string\n  provider_label string\n  citations ResearcherCitationInput[]\n  provider_calls ResearcherProviderCallSummary[]\n  fetched_pages ResearcherFetchedPageInput[]\n  raw_results_count int\n  errors string[]\n}\n\nclass ResearcherSynthesisOutput {\n  summary string\n  objective_status ResearcherObjectiveStatus\n  completion_reason string\n  recommended_next_capability string?\n  recommended_next_objective string?\n  key_findings string[]\n  gaps string[]\n  confidence float\n}\n\nfunction ResearcherPlanStep(input: ResearcherPlanInput) -> ResearcherPlanOutput {\n  client GLM47\n  prompt #\"\n    You are the ChoirOS Researcher planner.\n    Your job is to decide the next agentic step for this research run.\n\n    Objective: {{ input.objective }}\n    Current Query: {{ input.current_query }}\n    Round: {{ input.round }} / {{ input.max_rounds }}\n    Provider Hint: {{ input.provider_hint }}\n    Max Results Hint: {{ input.max_results_hint }}\n    Last Error: {{ input.last_error }}\n\n    Previous Provider Calls:\n    {{ input.provider_calls }}\n\n    Current Citations:\n    {{ input.citations }}\n\n    Fetched Pages:\n    {{ input.fetched_pages }}\n\n    Decision contract:\n    - Use action=Search when more evidence should be gathered.\n    - Use action=FetchUrl when one or more specific URLs need deeper extraction.\n    - Use action=Complete only when available evidence is sufficient for objective completion.\n    - Use action=Block when the objective cannot progress without another capability/human help.\n    - If action=Search: provide query and provider.\n      provider can be: \"auto\", \"tavily\", \"brave\", \"exa\", or comma list like \"tavily,exa\".\n    - If action=FetchUrl: provide fetch_url.\n    - If action=Complete or action=Block: include completion_reason.\n    - For broad objectives (for example \"what's the news?\"), favor multiple independent sources.\n    - Never ask for deterministic scoring/ranking logic. Use semantic judgment.\n    - Keep rationale concrete and short.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\nfunction ResearcherSummarizeEvidence(input: ResearcherSynthesisInput) -> ResearcherSynthesisOutput {\n  client GLM47\n  prompt #\"\n    You are the ChoirOS Researcher synthesizer.\n    Produce a semantic summary from gathered evidence and decide objective terminality.\n\n    Objective: {{ input.objective }}\n    Query: {{ input.query }}\n    Provider Label: {{ input.provider_label }}\n    Raw Results Count: {{ input.raw_results_count }}\n    Errors: {{ input.errors }}\n\n    Provider Calls:\n    {{ input.provider_calls }}\n\n    Citations:\n    {{ input.citations }}\n\n    Fetched Pages:\n    {{ input.fetched_pages }}\n\n    Output contract:\n    - summary should be an evidence-based briefing, not a raw link list.\n    - objective_status must be Complete, Incomplete, or Blocked.\n    - completion_reason must justify objective_status.\n    - key_findings should include the most meaningful semantic findings.\n    - gaps should list unresolved questions or weak evidence areas.\n    - recommended_next_capability/objective should be present if status is Incomplete or Blocked.\n    - Do not rely on deterministic thresholds in wording; judge semantically.\n\n    {{ ctx.output_format }}\n  \"#\n}\n".to_string());

        m.insert("resume.baml".to_string(), "// Defining a data model.\nclass Resume {\n  name string\n  email string\n  experience string[]\n  skills string[]\n}\n\n// Create a function to extract the resume from a string.\nfunction ExtractResume(resume: string) -> Resume {\n  // Specify a client as provider/model-name\n  // You can also use custom LLM params with a custom client name from clients.baml like \"client CustomGPT5\" or \"client CustomSonnet4\"\n  client \"openai-responses/gpt-5-mini\" // Set OPENAI_API_KEY to use this client.\n  prompt #\"\n    Extract from this content:\n    {{ resume }}\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n\n\n// Test the function with a sample resume. Open the VSCode playground to run this.\ntest vaibhav_resume {\n  functions [ExtractResume]\n  args {\n    resume #\"\n      Vaibhav Gupta\n      vbv@boundaryml.com\n\n      Experience:\n      - Founder at BoundaryML\n      - CV Engineer at Google\n      - CV Engineer at Microsoft\n\n      Skills:\n      - Rust\n      - C++\n    \"#\n  }\n}\n".to_string());

        m.insert("types.baml".to_string(), "// ChoirOS Chat Agent Types\n// Core types for BAML-powered chat agent with tool execution\n\n// Message in conversation\nclass Message {\n  role string\n  content string\n}\n\nclass BashToolArgs {\n  command string?\n  cmd string?\n  cwd string?\n  reasoning string?\n  timeout_ms int?\n  model string?\n}\n\nclass ReadFileToolArgs {\n  path string?\n  limit int?\n  offset int?\n}\n\nclass WriteFileToolArgs {\n  path string?\n  content string?\n}\n\nclass ListFilesToolArgs {\n  path string?\n  recursive bool?\n}\n\nclass SearchFilesToolArgs {\n  pattern string?\n  path string?\n  file_pattern string?\n}\n\nclass WebSearchToolArgs {\n  query string?\n  provider string?\n  max_results int?\n  time_range string?\n  include_domains string[]?\n  exclude_domains string[]?\n  timeout_ms int?\n  model string?\n  reasoning string?\n}\n\n// Individual tool call from the agent\nclass AgentToolArgs {\n  bash BashToolArgs?\n  read_file ReadFileToolArgs?\n  write_file WriteFileToolArgs?\n  list_files ListFilesToolArgs?\n  search_files SearchFilesToolArgs?\n  web_search WebSearchToolArgs?\n\n  // Legacy flat fields kept for compatibility with models that don't yet\n  // follow the nested per-tool schema.\n  command string?\n  cmd string?\n  cwd string?\n  reasoning string?\n  timeout_ms int?\n  model string?\n  path string?\n  content string?\n  pattern string?\n  file_pattern string?\n  recursive bool?\n  limit int?\n  offset int?\n  query string?\n  provider string?\n  max_results int?\n  time_range string?\n  include_domains string[]?\n  exclude_domains string[]?\n}\n\nclass AgentToolCall {\n  tool_name string\n  tool_args AgentToolArgs\n  reasoning string?\n}\n\n// The agent's plan - thinking, tool calls, and final response\nclass AgentPlan {\n  thinking string\n  tool_calls AgentToolCall[]\n  final_response string?\n  objective_status ObjectiveStatus?\n  plan_mode PlanMode?\n  completion_reason string?\n  confidence float\n}\n\n// Result of executing a tool\nclass ToolResult {\n  tool_name string\n  success bool\n  output string\n  error string?\n}\n\n// Streaming chunk types for WebSocket\nclass StreamChunk {\n  chunk_type string // \"thinking\", \"tool_call\", \"tool_result\", \"response\", \"error\"\n  content string\n}\n\n// Objective tracking and completion types\nenum ObjectiveStatus {\n  Satisfied\n  InProgress\n  Blocked\n}\n\nenum PlanMode {\n  CallTools\n  Finalize\n  Escalate\n}\n\nclass ObjectiveContract {\n  objective_id string\n  parent_objective_id string?\n  primary_objective string\n  success_criteria string[]\n  max_tool_calls int\n  timeout_ms int\n  attempts_budget int\n}\n\nclass CompletionPayload {\n  objective_status ObjectiveStatus\n  objective_fulfilled bool\n  completion_reason string\n  evidence Evidence[]\n  unresolved_items UnresolvedItem[]\n  recommended_next_action NextAction?\n}\n\nclass Evidence {\n  evidence_id string\n  evidence_type EvidenceType\n  source string\n  content string\n  confidence float\n  timestamp string\n}\n\nclass UnresolvedItem {\n  item_id string\n  description string\n  reason string\n}\n\nclass NextAction {\n  action_type NextActionType\n  recommended_capability string?\n  recommended_objective string?\n  rationale string\n}\n\nenum EvidenceType {\n  SearchResult\n  CodeSnippet\n  Documentation\n  TerminalOutput\n  FileContent\n  WebPage\n  Other\n}\n\nenum NextActionType {\n  Escalate\n  Continue\n  Complete\n}\n".to_string());

        m.insert("watcher.baml".to_string(), "// ChoirOS Watcher BAML Contracts\n// Event-log review and escalation functions for the Watcher actor\n//\n// The Watcher provides deterministic detection/alerting over logs.\n// These BAML functions enable LLM-powered review of event windows for\n// anomaly detection and mitigation recommendations.\n\n// ============================================================================\n// Input Types\n// ============================================================================\n\nclass WatcherLogWindowInput {\n  window_id string\n  run_id string\n  task_id string\n  events WatcherEvent[]\n  scope ReviewScope\n  review_reason string?  // Why this window is being reviewed\n}\n\nclass WatcherEvent {\n  event_id string\n  timestamp string\n  event_type string\n  level string  // info, warn, error, critical\n  payload string\n  source string  // which component emitted\n}\n\nclass ReviewScope {\n  start_time string\n  end_time string\n  event_types string[]\n  min_level string\n}\n\n// ============================================================================\n// Output Types - Review\n// ============================================================================\n\nenum ReviewStatus {\n  Clean\n  IssuesDetected\n  Critical\n  Inconclusive\n}\n\nenum EscalationKind {\n  FailureSpike\n  TimeoutPattern\n  ResourceExhaustion\n  SecurityConcern\n  CostAnomaly\n  StalledWorkflow\n  Other\n}\n\nenum UrgencyLevel {\n  Low\n  Medium\n  High\n  Critical\n}\n\nenum RiskCategory {\n  Operational\n  Technical\n  Security\n  Cost\n  Compliance\n}\n\nclass WatcherReviewOutput {\n  review_status ReviewStatus\n  escalations WatcherEscalation[]\n  risks RiskItem[]\n  anomalies DetectedAnomaly[]\n  confidence float\n  rationale string\n}\n\nclass WatcherEscalation {\n  escalation_id string\n  run_id string\n  task_id string\n  kind EscalationKind\n  urgency UrgencyLevel\n  affected_calls string[]\n  description string\n  recommended_action string\n  recommended_capability string?\n  recommended_objective string?\n}\n\nclass RiskItem {\n  risk_id string\n  category RiskCategory\n  likelihood float  // 0.0-1.0\n  impact float  // 0.0-1.0\n  description string\n  mitigating_factors string[]\n}\n\nclass DetectedAnomaly {\n  anomaly_type string\n  severity string\n  description string\n  affected_events string[]\n  pattern_detected string\n}\n\n// ============================================================================\n// Input Types - Mitigation\n// ============================================================================\n\nclass WatcherMitigationInput {\n  escalation WatcherEscalation\n  run_state RunStateSnapshot\n  available_capabilities string[]\n  historical_resolutions HistoricalResolution[]\n}\n\nclass RunStateSnapshot {\n  run_id string\n  status string\n  active_call_count int\n  recent_failures int\n  elapsed_time_ms int\n}\n\nclass HistoricalResolution {\n  pattern string\n  successful_resolution string\n  resolution_type string\n}\n\n// ============================================================================\n// Output Types - Mitigation\n// ============================================================================\n\nenum EscalationAction {\n  NotifyConductor\n  RequestHumanReview\n  AutoRetry\n  ScaleResources\n  TerminateRun\n  ContinueMonitoring\n  EscalateToOnCall\n}\n\nclass WatcherMitigationOutput {\n  escalation_action EscalationAction\n  urgency UrgencyLevel\n  recommended_capability string?\n  recommended_objective string?\n  rationale string\n  confidence float\n  expected_outcome string\n  alternatives AlternativeAction[]\n}\n\nclass AlternativeAction {\n  action EscalationAction\n  pros string[]\n  cons string[]\n  estimated_success_rate float\n}\n\n// ============================================================================\n// Function 1: WatcherReviewLogWindow\n// ============================================================================\n\nfunction WatcherReviewLogWindow(input: WatcherLogWindowInput) -> WatcherReviewOutput {\n  client GLM47\n  prompt #\"\n    You are the ChoirOS Watcher, an AI that reviews event logs for anomalies,\n    failures, and concerning patterns.\n\n    Your role is deterministic detection over logs - you identify issues that\n    may require escalation to the Conductor or human operators.\n\n    Window ID: {{ input.window_id }}\n    Run ID: {{ input.run_id }}\n    Task ID: {{ input.task_id }}\n\n    Review Reason: {{ input.review_reason }}\n\n    Review Scope:\n    - Start Time: {{ input.scope.start_time }}\n    - End Time: {{ input.scope.end_time }}\n    - Event Types: {{ input.scope.event_types }}\n    - Minimum Level: {{ input.scope.min_level }}\n\n    Events to Review ({{ input.events | length }} events):\n    {{ input.events }}\n\n    Review Guidelines:\n\n    1. **ReviewStatus Classification**:\n       - Clean: No issues detected, normal operation\n       - IssuesDetected: Minor issues found, may need attention\n       - Critical: Serious problems requiring immediate escalation\n       - Inconclusive: Cannot determine from available data\n\n    2. **Escalation Detection** - Create escalations for:\n       - FailureSpike: Multiple failures in short window\n       - TimeoutPattern: Repeated timeout errors\n       - ResourceExhaustion: High resource usage or limits hit\n       - SecurityConcern: Suspicious activity or auth failures\n       - CostAnomaly: Unexpected cost patterns\n       - StalledWorkflow: Tasks not progressing\n       - Other: Unclassified but concerning patterns\n\n    3. **Risk Assessment**:\n       - Evaluate likelihood (0.0-1.0) and impact (0.0-1.0)\n       - Categories: Operational, Technical, Security, Cost, Compliance\n       - List mitigating factors that reduce risk\n\n    4. **Anomaly Detection**:\n       - Identify unusual patterns in event sequences\n       - Note severity and affected events\n       - Describe the pattern detected (e.g., \"retry storm\", \"cascade failure\")\n\n    5. **Escalation Recommendations**:\n       - recommended_action: Clear, actionable next step\n       - recommended_capability: Which capability should handle this (if known)\n       - recommended_objective: What objective to assign (if applicable)\n       - urgency: Low, Medium, High, or Critical\n\n    Output Requirements:\n    - Use exact enum values for ReviewStatus, EscalationKind, UrgencyLevel, RiskCategory\n    - Confidence score 0.0-1.0 based on clarity of findings\n    - Provide clear rationale for all escalations and risks\n    - affected_calls should reference specific call IDs from events\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// ============================================================================\n// Function 2: WatcherRecommendMitigation\n// ============================================================================\n\nfunction WatcherRecommendMitigation(input: WatcherMitigationInput) -> WatcherMitigationOutput {\n  client GLM47\n  prompt #\"\n    You are the ChoirOS Watcher, recommending mitigation actions for detected issues.\n\n    Your role is to select the best action given an escalation and current run state,\n    including when to auto-retry vs request human review.\n\n    Escalation Details:\n    - ID: {{ input.escalation.escalation_id }}\n    - Kind: {{ input.escalation.kind }}\n    - Urgency: {{ input.escalation.urgency }}\n    - Description: {{ input.escalation.description }}\n    - Affected Calls: {{ input.escalation.affected_calls }}\n    - Recommended Action: {{ input.escalation.recommended_action }}\n    - Recommended Capability: {{ input.escalation.recommended_capability }}\n    - Recommended Objective: {{ input.escalation.recommended_objective }}\n\n    Current Run State:\n    - Run ID: {{ input.run_state.run_id }}\n    - Status: {{ input.run_state.status }}\n    - Active Calls: {{ input.run_state.active_call_count }}\n    - Recent Failures: {{ input.run_state.recent_failures }}\n    - Elapsed Time (ms): {{ input.run_state.elapsed_time_ms }}\n\n    Available Capabilities:\n    {{ input.available_capabilities }}\n\n    Historical Resolutions (similar patterns and their outcomes):\n    {{ input.historical_resolutions }}\n\n    Mitigation Guidelines:\n\n    1. **EscalationAction Selection**:\n       - NotifyConductor: Wake the Conductor for orchestration decision\n       - RequestHumanReview: Human judgment needed (ambiguous, high-stakes)\n       - AutoRetry: Safe to retry automatically (transient failures)\n       - ScaleResources: Increase resources (resource exhaustion)\n       - TerminateRun: Stop the run (unrecoverable, dangerous)\n       - ContinueMonitoring: Watch but don't act yet (inconclusive)\n       - EscalateToOnCall: Page the on-call engineer (critical production issue)\n\n    2. **Decision Matrix**:\n       - Transient failures (network, timeout) + low retry count -> AutoRetry\n       - Resource exhaustion + scaling available -> ScaleResources\n       - Ambiguous situation + high stakes -> RequestHumanReview\n       - Conductor available + complex coordination needed -> NotifyConductor\n       - Critical urgency + production impact -> EscalateToOnCall\n       - Unclear pattern + no historical success -> ContinueMonitoring\n\n    3. **Alternative Actions**:\n       - List 2-3 alternative actions with pros/cons\n       - Estimate success rate for each alternative\n       - Explain why the primary action was chosen\n\n    4. **Capability/Objectives**:\n       - recommended_capability: Which capability to invoke (if action requires it)\n       - recommended_objective: Clear objective statement for the capability\n       - These flow into the Conductor wake lane for orchestration\n\n    Output Requirements:\n    - Use exact enum values for EscalationAction and UrgencyLevel\n    - Confidence score 0.0-1.0 based on certainty of recommendation\n    - Provide clear rationale linking escalation to chosen action\n    - expected_outcome: What should happen if action is taken\n    - Include at least 2 alternatives with honest pros/cons\n\n    {{ ctx.output_format }}\n  \"#\n}\n".to_string());

        m
    })
}
