name: Nix CI/CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

concurrency:
  group: nix-ci-cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Detect relevant changes
    runs-on: ubuntu-latest
    outputs:
      build_all: ${{ steps.filter.outputs.build_all }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Filter changed paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            build_all:
              - '.github/workflows/nix-ci-draft.yml'
              - 'Cargo.toml'
              - 'Cargo.lock'
              - 'flake.nix'
              - 'flake.lock'
              - 'sandbox/**'
              - 'hypervisor/**'
              - 'dioxus-desktop/**'
              - 'shared-types/**'
              - 'nixos/**'

  build-sandbox:
    name: Build sandbox flake
    runs-on: ubuntu-latest
    needs: [changes]
    if: github.event_name == 'workflow_dispatch' || needs.changes.outputs.build_all == 'true'
    outputs:
      store_path: ${{ steps.build.outputs.store_path }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/determinate-nix-action@v3

      - name: Configure FlakeHub cache
        uses: DeterminateSystems/flakehub-cache-action@v3
        with:
          flakehub-flake-name: choir/choiros-rs
        env:
          FLAKEHUB_AUTH_TOKEN: ${{ secrets.FLAKEHUB_AUTH_TOKEN }}

      - name: Build flake package
        id: build
        run: |
          set -euo pipefail
          OUT_PATH="$(nix build ./sandbox#sandbox --no-link --json --print-build-logs | jq -r '.[0].outputs.out')"
          if [ -z "$OUT_PATH" ] || [ "$OUT_PATH" = "null" ]; then
            echo "Failed to resolve sandbox store path"
            exit 1
          fi
          echo "store_path=$OUT_PATH" >> "$GITHUB_OUTPUT"

  build-hypervisor:
    name: Build hypervisor flake
    runs-on: ubuntu-latest
    needs: [changes]
    if: github.event_name == 'workflow_dispatch' || needs.changes.outputs.build_all == 'true'
    outputs:
      store_path: ${{ steps.build.outputs.store_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/determinate-nix-action@v3

      - name: Configure FlakeHub cache
        uses: DeterminateSystems/flakehub-cache-action@v3
        with:
          flakehub-flake-name: choir/choiros-rs
        env:
          FLAKEHUB_AUTH_TOKEN: ${{ secrets.FLAKEHUB_AUTH_TOKEN }}

      - name: Build flake package
        id: build
        run: |
          set -euo pipefail
          OUT_PATH="$(nix build ./hypervisor#hypervisor --no-link --json --print-build-logs | jq -r '.[0].outputs.out')"
          if [ -z "$OUT_PATH" ] || [ "$OUT_PATH" = "null" ]; then
            echo "Failed to resolve hypervisor store path"
            exit 1
          fi
          echo "store_path=$OUT_PATH" >> "$GITHUB_OUTPUT"

  build-desktop:
    name: Build desktop flake
    runs-on: ubuntu-latest
    needs: [changes]
    if: github.event_name == 'workflow_dispatch' || needs.changes.outputs.build_all == 'true'
    outputs:
      store_path: ${{ steps.build.outputs.store_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/determinate-nix-action@v3

      - name: Configure FlakeHub cache
        uses: DeterminateSystems/flakehub-cache-action@v3
        with:
          flakehub-flake-name: choir/choiros-rs
        env:
          FLAKEHUB_AUTH_TOKEN: ${{ secrets.FLAKEHUB_AUTH_TOKEN }}

      - name: Build flake package
        id: build
        run: |
          set -euo pipefail
          OUT_PATH="$(nix build ./dioxus-desktop#desktop --no-link --json --print-build-logs | jq -r '.[0].outputs.out')"
          if [ -z "$OUT_PATH" ] || [ "$OUT_PATH" = "null" ]; then
            echo "Failed to resolve desktop store path"
            exit 1
          fi
          echo "store_path=$OUT_PATH" >> "$GITHUB_OUTPUT"

  deploy-ec2:
    name: Deploy EC2 via AWS SSM
    runs-on: ubuntu-latest
    needs: [changes, build-sandbox, build-hypervisor, build-desktop]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request' && (github.event_name == 'workflow_dispatch' || needs.changes.outputs.build_all == 'true')
    environment: production
    env:
      AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
      DEPLOY_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
      DEPLOY_SHA: ${{ github.sha }}
      SANDBOX_STORE_PATH: ${{ needs.build-sandbox.outputs.store_path }}
      HYPERVISOR_STORE_PATH: ${{ needs.build-hypervisor.outputs.store_path }}
      DESKTOP_STORE_PATH: ${{ needs.build-desktop.outputs.store_path }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate SSM target
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_INSTANCE_ID}" ]; then
            echo "Missing EC2_INSTANCE_ID secret"
            exit 1
          fi

          aws ssm describe-instance-information \
            --region "${AWS_REGION}" \
            --filters "Key=InstanceIds,Values=${DEPLOY_INSTANCE_ID}" \
            --query 'InstanceInformationList[0].PingStatus' \
            --output text | grep -q '^Online$'

      - name: Deploy via SSM
        run: |
          set -euo pipefail

          SCRIPT_B64="$(base64 -w0 <<'EOF'
          set -euo pipefail
          RELEASE_SHA="${DEPLOY_SHA}"
          WORKDIR='/opt/choiros/deploy-repo'
          REPO_URL='https://github.com/yusefmosiah/choiros-rs.git'
          SANDBOX_STORE_PATH="${SANDBOX_STORE_PATH:-}"
          HYPERVISOR_STORE_PATH="${HYPERVISOR_STORE_PATH:-}"
          DESKTOP_STORE_PATH="${DESKTOP_STORE_PATH:-}"

          if [ -z "$SANDBOX_STORE_PATH" ] || [ -z "$HYPERVISOR_STORE_PATH" ] || [ -z "$DESKTOP_STORE_PATH" ]; then
            echo "Missing one or more store paths from build jobs"
            exit 1
          fi

          if [ ! -d "$WORKDIR/.git" ]; then
            rm -rf "$WORKDIR"
            git clone "$REPO_URL" "$WORKDIR"
          fi
          cd "$WORKDIR"
          git fetch origin
          git checkout -f "$RELEASE_SHA"

          export NIX_CONFIG="fallback = false"
          nix-store --realise "$SANDBOX_STORE_PATH"
          nix-store --realise "$HYPERVISOR_STORE_PATH"
          nix-store --realise "$DESKTOP_STORE_PATH"

          install -m 0755 "$SANDBOX_STORE_PATH/bin/sandbox" /opt/choiros/bin/sandbox
          install -m 0755 "$HYPERVISOR_STORE_PATH/bin/hypervisor" /opt/choiros/bin/hypervisor
          install -m 0755 "$DESKTOP_STORE_PATH/bin/sandbox-ui" /opt/choiros/bin/sandbox-ui

          export NIX_PATH="nixpkgs=$(nix --extra-experimental-features nix-command --extra-experimental-features flakes eval --raw nixpkgs#path)"
          export NIXOS_CONFIG=/etc/nixos/configuration.nix
          nixos-rebuild switch

          dump_runtime_diagnostics() {
            echo "===== deploy diagnostics: sandbox containers ====="
            for container_name in sandbox-live sandbox-dev; do
              echo "===== deploy diagnostics: ${container_name} ====="
              nixos-container run "$container_name" -- systemctl show sandbox --property=ActiveState,SubState,ExecMainCode,ExecMainStatus || true
              nixos-container run "$container_name" -- systemctl status sandbox --no-pager -l || true
              nixos-container run "$container_name" -- journalctl -u sandbox --since '-15 min' -n 120 --no-pager || true
              nixos-container run "$container_name" -- ss -ltnp '( sport = :8080 )' || true
            done

            echo "===== deploy diagnostics: host ====="
            ss -ltnp '( sport = :9090 or sport = :8080 or sport = :8081 )' || true
            systemctl status hypervisor --no-pager -l || true
            journalctl -u hypervisor --since '-15 min' -n 120 --no-pager || true
            systemctl status container@sandbox-live --no-pager -l || true
            systemctl status container@sandbox-dev --no-pager -l || true
          }

          wait_http() {
            local url="$1"
            local timeout_secs="$2"
            local started_at
            started_at="$(date +%s)"

            while true; do
              if curl -fsS "$url" >/dev/null; then
                return 0
              fi

              if [ $(( $(date +%s) - started_at )) -ge "$timeout_secs" ]; then
                echo "Timed out waiting for $url"
                dump_runtime_diagnostics
                return 1
              fi

              sleep 2
            done
          }

          wait_container_port() {
            local container_name="$1"
            local port="$2"
            local timeout_secs="$3"
            local started_at
            started_at="$(date +%s)"

            while true; do
              if nixos-container run "$container_name" -- sh -lc "ss -ltn '( sport = :${port} )' | grep -q LISTEN"; then
                return 0
              fi

              if [ $(( $(date +%s) - started_at )) -ge "$timeout_secs" ]; then
                echo "Timed out waiting for ${container_name} to listen on ${port}"
                dump_runtime_diagnostics
                return 1
              fi

              sleep 2
            done
          }

          wait_container_http_healthy() {
            local container_name="$1"
            local url="$2"
            local timeout_secs="$3"
            local started_at
            local probe
            started_at="$(date +%s)"

            probe="
              if command -v curl >/dev/null 2>&1; then
                curl -fsS '${url}'
              elif command -v wget >/dev/null 2>&1; then
                wget -qO- '${url}'
              elif command -v busybox >/dev/null 2>&1; then
                busybox wget -qO- '${url}'
              else
                exit 127
              fi
            "

            while true; do
              if nixos-container run "$container_name" -- sh -lc "$probe" | grep -q '"status"[[:space:]]*:[[:space:]]*"healthy"'; then
                return 0
              fi

              if [ $(( $(date +%s) - started_at )) -ge "$timeout_secs" ]; then
                echo "Timed out waiting for healthy response from ${container_name} (${url})"
                echo "Last probe result:"
                nixos-container run "$container_name" -- sh -lc "$probe" || true
                dump_runtime_diagnostics
                return 1
              fi

              sleep 2
            done
          }

          wait_http http://127.0.0.1:9090/login 120
          wait_container_port sandbox-live 8080 120
          wait_container_port sandbox-dev 8080 120
          wait_container_http_healthy sandbox-live http://127.0.0.1:8080/health 120
          wait_container_http_healthy sandbox-dev http://127.0.0.1:8080/health 120
          echo "Deploy OK for $RELEASE_SHA"
          EOF
          )"

          COMMAND_ID="$(aws ssm send-command \
            --region "${AWS_REGION}" \
            --instance-ids "${DEPLOY_INSTANCE_ID}" \
            --document-name 'AWS-RunShellScript' \
            --comment "choiros deploy ${DEPLOY_SHA}" \
            --parameters "$(jq -cn --arg cmd "echo ${SCRIPT_B64} | base64 -d | DEPLOY_SHA='${DEPLOY_SHA}' SANDBOX_STORE_PATH='${SANDBOX_STORE_PATH}' HYPERVISOR_STORE_PATH='${HYPERVISOR_STORE_PATH}' DESKTOP_STORE_PATH='${DESKTOP_STORE_PATH}' bash" '{commands: [$cmd]}')" \
            --query 'Command.CommandId' \
            --output text)"

          for _ in $(seq 1 120); do
            STATUS="$(aws ssm get-command-invocation \
              --region "${AWS_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${DEPLOY_INSTANCE_ID}" \
              --query 'Status' \
              --output text 2>/dev/null || true)"

            case "$STATUS" in
              Success)
                break
                ;;
              Failed|Cancelled|TimedOut)
                echo "SSM command ended with status: $STATUS"
                aws ssm get-command-invocation \
                  --region "${AWS_REGION}" \
                  --command-id "${COMMAND_ID}" \
                  --instance-id "${DEPLOY_INSTANCE_ID}" \
                  --output json
                exit 1
                ;;
              *)
                sleep 10
                ;;
            esac
          done

          if [ "${STATUS:-}" != "Success" ]; then
            echo "SSM command did not reach Success within timeout window (last status: ${STATUS:-unknown})"
            aws ssm get-command-invocation \
              --region "${AWS_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${DEPLOY_INSTANCE_ID}" \
              --output json || true
            exit 1
          fi

          aws ssm get-command-invocation \
            --region "${AWS_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${DEPLOY_INSTANCE_ID}" \
            --query '{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}' \
            --output json

      - name: Publish rollback notes
        run: |
          {
            echo "## Rollback quick path"
            echo
            echo "- EC2 host rollback: \`sudo nixos-rebuild switch --rollback\`"
            echo "- EC2 host generation list: \`sudo nix-env --list-generations --profile /nix/var/nix/profiles/system\`"
            echo "- Release commit: \`${{ github.sha }}\`"
            echo "- Repo path on host: \`/opt/choiros/workspace\`"
            echo "- Service restart after rollback: \`sudo systemctl restart container@sandbox-live container@sandbox-dev hypervisor\`"
          } >> "$GITHUB_STEP_SUMMARY"
