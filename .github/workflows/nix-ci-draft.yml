name: Nix CI/CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

concurrency:
  group: nix-ci-cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Detect relevant changes
    runs-on: ubuntu-latest
    outputs:
      build_all: ${{ steps.filter.outputs.build_all }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Filter changed paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            build_all:
              - '.github/workflows/nix-ci-draft.yml'
              - 'Cargo.toml'
              - 'Cargo.lock'
              - 'flake.nix'
              - 'flake.lock'
              - 'scripts/deploy/**'
              - 'sandbox/**'
              - 'hypervisor/**'
              - 'dioxus-desktop/**'
              - 'shared-types/**'
              - 'nixos/**'

  build-sandbox:
    name: Build sandbox flake
    runs-on: ubuntu-latest
    needs: [changes]
    if: github.event_name == 'workflow_dispatch' || needs.changes.outputs.build_all == 'true'
    outputs:
      store_path: ${{ steps.build.outputs.store_path }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/determinate-nix-action@v3

      - name: Configure FlakeHub cache
        uses: DeterminateSystems/flakehub-cache-action@v3
        with:
          flakehub-flake-name: choir/choiros-rs
        env:
          FLAKEHUB_AUTH_TOKEN: ${{ secrets.FLAKEHUB_AUTH_TOKEN }}

      - name: Build flake package
        id: build
        run: |
          set -euo pipefail
          OUT_PATH="$(nix build ./sandbox#sandbox --no-link --json --print-build-logs | jq -r '.[0].outputs.out')"
          if [ -z "$OUT_PATH" ] || [ "$OUT_PATH" = "null" ]; then
            echo "Failed to resolve sandbox store path"
            exit 1
          fi
          echo "store_path=$OUT_PATH" >> "$GITHUB_OUTPUT"

  build-hypervisor:
    name: Build hypervisor flake
    runs-on: ubuntu-latest
    needs: [changes]
    if: github.event_name == 'workflow_dispatch' || needs.changes.outputs.build_all == 'true'
    outputs:
      store_path: ${{ steps.build.outputs.store_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/determinate-nix-action@v3

      - name: Configure FlakeHub cache
        uses: DeterminateSystems/flakehub-cache-action@v3
        with:
          flakehub-flake-name: choir/choiros-rs
        env:
          FLAKEHUB_AUTH_TOKEN: ${{ secrets.FLAKEHUB_AUTH_TOKEN }}

      - name: Build flake package
        id: build
        run: |
          set -euo pipefail
          OUT_PATH="$(nix build ./hypervisor#hypervisor --no-link --json --print-build-logs | jq -r '.[0].outputs.out')"
          if [ -z "$OUT_PATH" ] || [ "$OUT_PATH" = "null" ]; then
            echo "Failed to resolve hypervisor store path"
            exit 1
          fi
          echo "store_path=$OUT_PATH" >> "$GITHUB_OUTPUT"

  build-desktop:
    name: Build desktop flake
    runs-on: ubuntu-latest
    needs: [changes]
    if: github.event_name == 'workflow_dispatch' || needs.changes.outputs.build_all == 'true'
    outputs:
      store_path: ${{ steps.build.outputs.store_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/determinate-nix-action@v3

      - name: Configure FlakeHub cache
        uses: DeterminateSystems/flakehub-cache-action@v3
        with:
          flakehub-flake-name: choir/choiros-rs
        env:
          FLAKEHUB_AUTH_TOKEN: ${{ secrets.FLAKEHUB_AUTH_TOKEN }}

      - name: Build flake package
        id: build
        run: |
          set -euo pipefail
          OUT_PATH="$(nix build ./dioxus-desktop#desktop --no-link --json --print-build-logs | jq -r '.[0].outputs.out')"
          if [ -z "$OUT_PATH" ] || [ "$OUT_PATH" = "null" ]; then
            echo "Failed to resolve desktop store path"
            exit 1
          fi
          echo "store_path=$OUT_PATH" >> "$GITHUB_OUTPUT"

  deploy-ec2:
    name: Deploy EC2 via AWS SSM
    runs-on: ubuntu-latest
    needs: [changes, build-sandbox, build-hypervisor, build-desktop]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request' && (github.event_name == 'workflow_dispatch' || needs.changes.outputs.build_all == 'true')
    environment: production
    env:
      AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
      DEPLOY_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
      DEPLOY_SHA: ${{ github.sha }}
      SANDBOX_STORE_PATH: ${{ needs.build-sandbox.outputs.store_path }}
      HYPERVISOR_STORE_PATH: ${{ needs.build-hypervisor.outputs.store_path }}
      DESKTOP_STORE_PATH: ${{ needs.build-desktop.outputs.store_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate SSM target
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_INSTANCE_ID}" ]; then
            echo "Missing EC2_INSTANCE_ID secret"
            exit 1
          fi

          aws ssm describe-instance-information \
            --region "${AWS_REGION}" \
            --filters "Key=InstanceIds,Values=${DEPLOY_INSTANCE_ID}" \
            --query 'InstanceInformationList[0].PingStatus' \
            --output text | grep -q '^Online$'

      - name: Deploy via SSM
        run: |
          set -euo pipefail

          SCRIPT_PATH='scripts/deploy/host-switch.sh'
          if [ ! -f "${SCRIPT_PATH}" ]; then
            echo "Missing deploy host script: ${SCRIPT_PATH}"
            exit 1
          fi
          SCRIPT_B64="$(base64 < "${SCRIPT_PATH}" | tr -d '\n')"

          COMMAND_ID="$(aws ssm send-command \
            --region "${AWS_REGION}" \
            --instance-ids "${DEPLOY_INSTANCE_ID}" \
            --document-name 'AWS-RunShellScript' \
            --comment "choiros deploy ${DEPLOY_SHA}" \
            --parameters "$(jq -cn --arg cmd "echo '${SCRIPT_B64}' | base64 -d > /tmp/choiros-host-switch.sh && chmod +x /tmp/choiros-host-switch.sh && RELEASE_SHA='${DEPLOY_SHA}' WORKDIR='/opt/choiros/deploy-repo' SANDBOX_STORE_PATH='${SANDBOX_STORE_PATH}' HYPERVISOR_STORE_PATH='${HYPERVISOR_STORE_PATH}' DESKTOP_STORE_PATH='${DESKTOP_STORE_PATH}' bash /tmp/choiros-host-switch.sh" '{commands: [$cmd]}')" \
            --query 'Command.CommandId' \
            --output text)"

          for _ in $(seq 1 120); do
            STATUS="$(aws ssm get-command-invocation \
              --region "${AWS_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${DEPLOY_INSTANCE_ID}" \
              --query 'Status' \
              --output text 2>/dev/null || true)"

            case "$STATUS" in
              Success)
                break
                ;;
              Failed|Cancelled|TimedOut)
                echo "SSM command ended with status: $STATUS"
                aws ssm get-command-invocation \
                  --region "${AWS_REGION}" \
                  --command-id "${COMMAND_ID}" \
                  --instance-id "${DEPLOY_INSTANCE_ID}" \
                  --output json
                exit 1
                ;;
              *)
                sleep 10
                ;;
            esac
          done

          if [ "${STATUS:-}" != "Success" ]; then
            echo "SSM command did not reach Success within timeout window (last status: ${STATUS:-unknown})"
            aws ssm get-command-invocation \
              --region "${AWS_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${DEPLOY_INSTANCE_ID}" \
              --output json || true
            exit 1
          fi

          aws ssm get-command-invocation \
            --region "${AWS_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${DEPLOY_INSTANCE_ID}" \
            --query '{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}' \
            --output json

      - name: Publish rollback notes
        run: |
          {
            echo "## Rollback quick path"
            echo
            echo "- EC2 host rollback: \`sudo nixos-rebuild switch --rollback\`"
            echo "- EC2 host generation list: \`sudo nix-env --list-generations --profile /nix/var/nix/profiles/system\`"
            echo "- Release commit: \`${{ github.sha }}\`"
            echo "- Repo path on host: \`/opt/choiros/workspace\`"
            echo "- Service restart after rollback: \`sudo systemctl restart container@sandbox-live container@sandbox-dev hypervisor\`"
          } >> "$GITHUB_STEP_SUMMARY"
